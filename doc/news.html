<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Kawa News and Change Summary</title>
<link rel="stylesheet" title="Kawa (navbar: fixed, left)"
  href="style/kawa-l.css" media="screen, print, projection, tv">
<link rel="alternate stylesheet" title="Kawa (navbar: fixed, right)"
  href="style/kawa-r.css" media="screen, print, projection, tv">
  </head>

<body id="body">
<div class="navcol">
<div class="logo"><a href="index.html"><img src="style/kawa-logo.png"></a></div>
<div class="navbar">
<!--start-generated-navbar-->
<ul>
<li><a rel="bookmark" href="news.html">News: Recent changes</a>
<!--start-children-toc-->
<ul parent="index.html">
</ul>
<!--end-children-toc-->
</li>
<li><a href="Installation.html">Getting and installing Kawa</a></li>
<li><a href="Running.html">Usage Reference</a></li>
<li><a href="toc.html">Language Reference</a></li>
<li><a href="Community.html">The Kawa Community</a></li>
<li><a href="License.html">License</a></li>
</ul>
<!--end-generated-navbar-->
</div>
</div>

<h1>Kawa News and Change Summary</h1>
<p>
These changes are in more-or-less reverse chronological order,
with the most recent changes first.</p>
<p>
See also the list of <a href="../qexo/news.html">Qexo (XQuery)-specific
changes</a>.

<h2>In Subversion repository since last release</h2>

<ul>
<li><p>
The treatment of keywords is changing to not be self-evaluating
(in Scheme).  If you want a literal keyword, you should quote it.
Unquoted keywords should only be used for keyword arguments.
The compiler now warns about badly former keyword arguments,
for example if a value is missing following a keyword.
<li><p>
The default is now Java 7, rather than Java 6.
This means the checked-in source code is pre-processed for Java 7,
and future binary releases will require Java 7.
<li><p>
The behavior of parameters and fluid variables has changed.
Setting a parameter no longer changes its value in already-running sub-threads.
The implementation is simpler and should be more efficient.</p>
<li><p>The form <code>define-early-constant</code> is similar to
<code>define-constant</code>, but it is evaluated in a module's
class initializer (or constructor in the case of a non-static definition).
<li><p>Even more of R7RS is now working:
<ul>
<li><p>Implemented and documented R7RS exception handling:
The syntax <code>guard</code> and the procedures <code>with-exception-handler</code> ,
@code{raise}, and @code{raise-continuable| all work.
The <code>error</code> procedure is R7RS-compatible, and the
procedures <code>error-object?</code>, <code>error-object-message</code>,
<code>error-object-irritants</code>, <code>file-error?</code>,
and <code>read-error?</code> were implemented.</p></li>
<li><p>Implemented <code>emergency-exit</code>, and modified <code>exit</code>
so finally-blocks are executed.</p></li>
<li><p>Implemented <code>exact-integer?</code>, <code>floor/</code>,
<code>floor-quotient</code>, <code>floor-remainder</code>,
<code>truncate/</code>, <code>truncate-quotient</code>,
and <code>truncate-remainder</code>.
<li><p>The <code>letrec*</code> syntax is now supported.
(It works the same as <code>letrec</code>, which is an
allowed extension of <code>letrec</code>.)</p></li>
<li><p>
The functions <code>utf8-&gt;string</code>
and <code>string-&gt;utf8</code> are now documented in the manual.</p></li>
<li><p>More pieces of R7RS-style library functionality are working:
The keyword <code>export</code> is now a synonym for <code>module-export</code>,
and both support the <code>rename</code> keyword.
The <code>prefix</code> option of <code>import</code> now works.</p></li>
</ul></li>
<!--OK to here, except where DOCUMENT noted-->
<!-- splice operator @ -->
<!-- TODO
<li>current-path
<li> &amp;&lt;{pname}  &amp;&gt;{pname}  &amp;&gt;&gt;{pname}
-->
<li><p>The changes to characters and strings are worth covering separately:
<ul>
<li><p>The <code>character</code> type is now a new primitive type
(implemented as <code>int</code>).  This can avoid boxing (object allocation)
<li><p>
There is also a new <code>character-or-eof</code>.
(A union of <code>character</code> and the EOF value, except the
latter is encoded as -1, thus avoiding object allocation.)
The functions <char>read-char</code> and <code>pek-char</code> now
return a <code>character-or-eof</code> value.
<li><p>Functions like <code>string-ref</code> that take a character
index would not take into account non-BMP characters (those whose value
is greater than <code>#xffff</code>, thus requiring two surrogate character).
This was contrary to R6RS/R7RS.  This has been fixed, though at some
performance cost .  (For example <code>string-ref</code> and
<code>string-length</code> are no longer constant-time.)
<li><p>Implemented as <code>string-cursor</code> API (based on Chibi Scheme).
Thes allow efficient indexing, based on opaque cursors (actually
counts of 16-bits <code>char</code>s).
<li><p>Optimized <code>string-for-each</code>, which is now the
preferred way to iterate through a string.
<li><p>Implemented <code>string-map</code>.
<li><p>New function <code>string-append!</code> for in-place
appending to a mutable string.
<li><p>New function <code>string-replace!</code> for replacing a
substring of a string with some other string.
</ul>
</li>
<li><p>The SRFI-13 function <code>string-append/shared</code>
is no longer automatically visible; you have to
<code>(import (srfi :13 strings))</code> or similar.
<li><p>The <code>module-name</code> form allows the name to be a list,
as in a R6RS/R7RS-style library name. <!--DOCUMENT-->
<li>
The syntax <code>@<var>expression</var></code> is a <em>splicing form</em>.
The <code><var>expression</var></code> must evaluate to a sequence
(vector, list, array, etc).  The function application or
constructor form is is equivalent to all the elements of the sequence.
<!--DOCUMENT-->
<li><p>
Add convenience procedures and syntax for working with processes:
<code>run-process</code>, <code>process-exit-wait</code>,
<code>process-exit-ok?</code>, <code>&amp;cmd</code>, <code>&amp;`</code>,
<code>&amp;sh</code>, <code>path-bytes</code>, and <code>path-data</code>.
Read <a href="http://per.bothner.com/blog/2014/Kawa-shell-programming/">about processes</a>.
We also introduce <a href="http://per.bothner.com/blog/2014/text-and-binary-data/">"blobs" which may be text or binary depending on context</a>.
<li><p>The initial values of <code>(current-output-port)</code>
and <code>(current-error-port)</code> are now hybrid textual/binary ports.
This means you can call <code>write-bytevector</code>
and <code>write-u8</code> on them, making it possible for an application
to write binary data to standard output.</p></li>
<li><p>The <code>cond-expand</code> features <code>java-6</code>
though <code>java-9</code> are now set based on the
<code>System</code> property <code>"java.version"</code>
(rather than how Kawa was configured).
<li><p>An Emacs-style <code>coding</code> declaration allows you
to specify the encoding of a Scheme source file.
<li><p>
<a href="http://srfi.schemers.org/srfi-60/srfi-60.html">SRFI-60 (Integers as Bits)</a> is now fully implemented.</p></li>
<li><p>Ported <a href="http://srfi.schemers.org/srfi-101/srfi-101.html">SRFI-101 (Purely Functional Random-Access Pairs and Lists)</a>. These are immutable (read-only) lists with fast (logarithmic) indexing and functional
update (i.e. return a modified list).
These are implemented by a <code>RAPair</code> class
which extends the generic <code>pair</code> type, which means that most
code that expects a standard list will work on these lists as well.</p></li>
<!-- FIXME When updating manual, incorporate SRFI-101 license/copyright. -->
<li><p>The class <code>kawa.lib.kawa.expressions</code>
contains an experimental Scheme API for manipulating and validating expressions.
<li><p>Internal: Changed representation used for multiple values
to an abstract class with multiple implementations.</p></li>
<!-- Partial re-formatting to more common Java standards -->
<li><p>Internal: Various I/O-related classes moved to new
package <code>gnu.kawa.io</code>.</p></li>
<li><p>Various changes to the <code>configure+make</code> build framework:
A C compiler is now only needed if you configure with
<code>--enable-kawa-frontend</code>;
Improved support for building under Windows (using MinGW/MSYS).</p></li>
<li><p>Support for building with <a href="http://gcc.gnu.org/java/">GCJ</a> was removed.</p></li>
</ul>

<h2>Kawa 1.14 (October 4, 2013)</h2>
<ul>
<li><p>You can pass flags from the <code>kawa</code> front-end to the
<code>java</code> launcher using <code>-J</code> and <code>-D</code> flags.
The <code>kawa</code> front-end now passes the
<code>kawa.command.line</code> property to Java; this is
used by the <code>(command-line)</code> procedure.
<li><p>Various improvements to the shell-script handling, including
<a href="Scripts.html">re-written documentation</a>.
<li><p>Some initial  support for Java 8.</p></li>
<li><p>More of R7RS is now working:
<ul>
<li>
After adding list procedures <code>make-list</code>, <code>list-copy</code>,
<code>list-set!</code> all the R7RS list procedures are implemented.
<li>Other added procedures: <code>square</code>,
<code>boolean=?</code>, <code>string-copy!</code>,
<code>digit-value</code>,
<code>get-environment-variable</code>, <code>get-environment-variables</code>,
<code>current-second</code>, <code>current-jiffy</code>,
<code>jiffies-per-second</code>, and <code>features</code>.
<li>
The predicates <code>finite?</code>, <code>infinite?</code>, and
<code>nan?</code> are generalized to complex numbers.
<li>
The procedures <code>write</code>, <code>write-simple</code>,
and <code>write-shared</code> are now consistent with R7RS.
<li>
String and character comparison functions are generalized to more
than two arguments (but restricted to strings or characters, respectively).
<li>
The procedures <code>string-copy</code>, <code>string-&gt;list</code>,
and <code>string-fill!</code> now take optional (start,end)-bounds.
All of the R7RS string functions are now implemented.
<li>
Support <code>=&gt;</code> syntax in <code>case</code> form.
<li>
Support backslash-escaped special characters in symbols
when inside vertical bars, such as <code>'|Hello\nworld|</code>.
<li>
The new functions and syntax are documented in
the <a href="index.html">Kawa manual</a>; look for the functions in the
<a href="Overall-Index.html">index</a>.
</ul></li>
<li><p>Added <code>define-private-alias</code> keyword.
<li><p>Extended <a href="Strings.html#String-templates">string quasi-literals
(templates)</a> as specified by <a href="http://srfi.schemers.org/srfi-109/srfi-109.html">SRFI-109</a>.  For example,
if <code>name</code> has the value <code>"John"</code>, then:
<pre>
&{Hello &[name]!}
</pre>
evaluates to: <code>"Hello John!"</code>.
<li><p>Named quasi-literal constructors as specified by <a href="http://srfi.schemers.org/srfi-108/srfi-108.html">SRFI-108</a>.
<li><p>A symbol having the form <code>-&gt;<var>type</var></code> is a type
conversion function that converts a value to <code><var>type</var></code>.
<li><p>New and improved check for void-valued expressions in a
context requiring a value.
This is controlled by the new option <code>--warn-void-used</code>,
which defaults to true.</p>
<li><p>The <code>datum->syntax</code> procedure takes an
optional third parameter to specify the source location.
See <code>testsuite/srfi-108-test.scm</code> for an example.
<li><p>Instead of specifying <code>--main</code> the command line,
you can now specify <code>(module-compile-options: main: #t)</code> in
the Scheme file.  This makes it easier to compile one or more
application (main) modules along with other modules.
<li><p>A change to the data structure used to detect never-returning
procedure uses a lot less memory. (Kawa 1.13 implemented a
conservative detection of when a procedure cannot return.
This analysis would sometimes cause the Kawa compiler to run out of memory.
The improved analysis uses the same basic algorithm, but
with a more space-efficient <q>inverted</q> data structure.)
<li><p>Multiple fixes to get Emacs Lisp (JEmacs) working (somewhat) again.
</ul>

<h2>Kawa 1.13 (December 10, 2012)</h2>

<ul>
<li><p>We now do a simple (conservative) analysis of when a procedure
cannot return.  This is combined with earlier and more precise analysis
of reachable code.  Not only does this catch programmer errors better,
but it also avoids some internal compiler errors, because Kawa could
get confused by unreachable code.
</li>
<li><p>Implement 2-argument version of <code>log</code> function,
as specified by R6RS and R7RS (and, prematurely, the Kawa documentation).
<li><p>Implement the R7RS <code>bytevector</code> functions.
The <code>bytevector</code> type is a synonym for older
<code>u8vector</code> type.</p></li>
<li><p>Implement R7RS <code>vector</code> procedures.
Various procedures now take (start,end)-bounds.</p></li>
<li><p>Implement most of the R7RS input/output proecdures.
Most significant enhancement is support for R7RS-conforming binary ports.
<li><p>Various enhancements to the manual, including merging in
lots of text from R7RS.
<li><p>Improved Android support, including a more convenient
Ant script contributed by Julien Rousseau.
Also, documentation merged into manual.
</ul>

<h2>Kawa 1.12 (May 30, 2012)</h2>
<ul>
<li><p>Implement a compile-time data-flow framework,
similar to Single Static Assignment.
This enables better type inference, improves some warnings/errors,
and enables some optimizations.
</p></li>
<li><p>Jamison Hope added support for co-variant return types and
bridge methods for generics.
<li>Macros were improved and more standards-conforming:
<ul>
<li><code>datum-&gt;syntax</code> and <code>syntax-&gt;datum</code>
are preferred names for <code>datum-&gt;syntax-object</code> and <code>syntax-object-&gt;datum</code>.
<li><p>Implemented <code>bound-identifier=?</code>
and re-wrote implementation of <code>free-identifier=?</code>.</p></li>
<li>Implement <code>unsyntax</code> and <code>unsyntax-splicing</code>,
along with the reader prefixes <code>#,</code> and <code>#,@</code>.
</ul>
<li><p>
New and improved lazy evaluation functionality:
<ul>
<li><p>Lazy values (resulting from <code>delay</code> or <code>future</code>)
are implicitly forced as needed.
This makes <q>lazy programming</q> more convenient.
<li><p>New type <code>promise</code>.
<li><p>The semantics of promises (<code>delay</code> etc) is now compatible with
<a href="http://srfi.schemers.org/srfi-45/srfi-45.html">SRFI 45</a>.
<li><p>
<q>Blank promises</q> are useful for passing data between processes,
logic programmming, and more. 
New functions <code>promise-set-value!</code>, <code>promise-set-alias!</code>,
<code>promise-set-exception!</code>, and <code>promise-set-thunk!</code>.
<li><p>The stream functions of <a href="http://srfi.schemers.org/srfi-41/srfi-41.html">SRFI-41</a> were re-implemented to use the new promise functionality.
</ul></li>
<li><p>Different functions in the same module can be compiled with or
without full tailcall support.  You can control this by using
<code>full-tailcalls</code> in <code>with-compile-options</code>.
You can also control <code>full-tailcalls</code> using
<code>module-compile-options</code>.</p></li>
<li><p>Charles Turner (sponsored by
<a href="http://code.google.com/soc/">Google's Summer of Code</a>)
enhanced the printer with support for <a href="http://srfi.schemers.org/srfi-38/">SRFI-38: External Representation for Data With Shared Structure</a>.</p></li>
<li><p>Optimize tail-recursion in module-level procedures.
(We used to only do this for internal functions, for reasons
that are no longer relevant.)</p></li>
<li><p>Add support for building Kawa on Windows using configure+make
(autotools) and Cygwin.</p></li>
<li><p>Some support for parameterized (generic) types:
<pre>
  Type[Arg1 Arg2 ... ArgN]
</pre>
is more-or-less equivalent to Java's:
<pre>
  Type&lt;Arg1, Arg2, ..., ArgN&gt;
</pre></p></li>
<li><p>New language options <code>--r5rs</code>,  <code>--r6rs</code>,
and  <code>--r7rs</code> provide better compatibility with those
Scheme standards.  (This is a work-in-progress.)
For example <code>--r6rs</code> aims to disable Kawa extensions
that conflict with R6RS.  It does not aim to disable all extensions,
only incompatible extensions.
So far these extensions disable the colon operator and keyword literals.
Selecting <code>--r5rs</code> makes symbols by default
case-insensitive.</p></li>
<li><p>The special tokens <code>#!fold-case</code> and
 <code>#!no-fold-case</code> act like comments except they
enable or disable case-folding of symbols.
The old <code>symbol-read-case</code> global is now only checked
when a LispReader is created, not each time a symbol is read.
<li><p>You can now use square brackets to construct immutable sequences
(vectors).
<li><p>A record type defined using <code>define-record-type</code>
is now compiled to a class that is a member of the module class.</p></li>
<li><p>Annotations are now supported.
<a href="http://per.bothner.com/blog/2011/Using-JAXB-annotations/">This example</a> shows how to use <a href="http://java.sun.com/xml/downloads/jaxb.html">JAXB</a> annotations to automatically convert between between Java objects and XML files.
<li><p>Prevent mutation of vector literals.</p></li>
<li><p>More R6RS procedures: <code>vector-map</code>,
<code>vector-for-each</code>, <code>string-for-each</code>, <code>real-valued?</code>, <code>rational-valued?</code>, <code>integer-valued?</code>, <code>finite?</code>, <code>infinite?</code>, <code>nan?</code>, <code>exact-integer-sqrt</code>.</p></li>
<li><p><a href="http://srfi.schemers.org/srfi-14/srfi-14.html">SRFI-14</a> ("character sets") and <a href="http://srfi.schemers.org/srfi-41/srfi-41.html">SRFI-41</a> ("streams") are now supported, thanks to porting done by Jamison Hope.</p>
<li><p>Kawa now runs under JDK 1.7.  This mostly involved fixing some
errors in <code>StackMapTable</code> generation.</p></li>
<li><p>You can now have a class created by <code>define-simple-class</code>
with the same name as the module class.  For example <code>(define-simple-class foo ...)</code> in a file <code>foo.scm</code>.  The defined class will
serve dual-purpose as the module class.
<li><p>Improvements in separating compile-time from run-time code, reducing the
size of the runtime jar used for compiled code.
<li><p>In the <code>cond-expand</code> conditional form you can
now use <code>class-exists:<var>ClassName</var></code> as a
feature <q>name</q> to tests that <code><var>ClassName</var></code> exists.
</ul>

<h2>Kawa 1.11 (November 11, 2010)</h2>
<ul>
<li><p>A new Kawa logo, contributed by <a href="http://jcubic.pl">Jakub Jankiewicz</a>.
<li><p>A new <code>--warn-unknown-member</code> option, which generalizes
<code>--warn-invoke-unknown-method</code> to fields as well as methods.
<li><p>A new <a href="ant-kawac.html"><code>kawac</code> task</a>, useful for Ant <code>build.xml</code> files, contributed by Jamison Hope.
<li><p><a href="http://per.bothner.com/blog/2010/AndroidHelloScheme">Updated Android support</a>.
<li><p>New <a href="Enumerations.html"><code>define-enum</code> macro</a> contributed by Jamison Hope.
<li><p>Access specifiers <code>'final</code> and <code>'enum</code> are now allowed in <code>define-class</code> and related forms.
<li><p>Optimized <code>odd?</code> and <code>even?</code>.
<li><p>If you specify the type of a <code>#!rest</code> parameter
as an array type, that will now be used for the "varargs" method parameter.
(Before only object arrays did this.)
<li><p>When constructing an object and there is no matching
constructor method, look for "<code>add</code>" methods in addition
to "<code>set</code>" methods.  Also, allow passing constructor args
as well as keyword setters.
<a href="Allocating-objects.html">See here</a> for the gory details.
<li><p>New <code>expand</code> function (contributed by Helmut Eller,
and enabled by <code>(require 'syntax-utils)</code>) for
converting Scheme expressions to macro-expanded forms.
<li><p><a href="Anonymous-classes.html#SAM-conversion">SAM-conversion<a>: In a context that expects a Single Abstract Method (SAM) type
(for example <code>java.lang.Runnable</code>), if you pass a lambda
you will get an <code>object</code> where the lambda implements
the abstract method.</p></li>
<li><p>In interactive mode allow dynamic rebinding of procedures.
I.e. if you re-define a procedure, the old procedure objects gets modified
in-place and re-used, rather than creating a new procedure object.  Thus calls
in existing procedures will call the new version.</p></li>
<li><p>Fix various threading issues related to compilation and eval.</p></li>
<li><p>When <code>format</code> returns a string, return a
<code>java.lang.String</code> rather than a <code>gnu.lists.FString</code>.
Also, add some minor optimization.
<li><p>Inheritance of environments and fluid variables now work properly
for all child threads, not just ones created using <code>future</code>.</p></li>
</ul>

<h2>Kawa 1.10 (July 24, 2010)</h2>
<ul>
<li><p>Now defaults to using Java 6, when compiling from source.
The pre-built <code>jar</code> works with Java 5, but makes
use of some Java 6 features (<code>javax.script</code>, built-in HTTP server) if available.
<li><p>You can write <a href="XML-literals.html">XML literals</a> in Scheme code prefixed by a <code>#</code>, for example:</p>
<pre>
#&lt;p&gt;The result is &amp;{result}.&lt;/p&gt;
</pre>
</li>
<li><p>New functions <code>element-name</code>
and <code>attribute-name</code>.
<li><p>Various <a href="Server-side-scripts.html">Web server improvements</a>.
You have the option of using JDK 6's builtin
<a href="Options.html#Options-for-web-servers">web-server</a>
for <a href="Self-configuring-page-scripts.html">auto-configued web pages</a>.
Automatic import of web server functions, so
you should not need to <code>(import 'http)</code> any more.
<li><p>Kawa <a href="Hash-tables.html">hashtables</a> now extend <code>java.util.Map</code>.</p></li>
<li><p>If a source file is specified on the <code>kawa</code> command line
without any options, it is read and compiled as a whole module
before it is run.  In contrast, if you want to read and evaluate a
source file line-by-line you must use the <code>-f</code> flag.</p></li>
<li><p>You can specify a class name on the <code>kawa</code> command line:
<pre>
$ kawa fully.qualified.name
</pre>
This is like the <code>java</code> command. but you don't need to
specify the path to the Kawa runtime library, and you don't need a
<code>main</code> method (as long as the class is <code>Runnable</code>).
<li><p>The usual bug-fixes, including better handling of the <code>~F</code>
<code>format</code> directive; and fix in handling of macro hygiene of the <code>lambda</code> (<a href="https://savannah.gnu.org/bugs/index.php?27042">bug #27042</a>).</p></li>
<li><p>Spaces are now optional before and after the '::' in type specifiers.
The preferred syntax leave no space after the '::', as in:
<pre>
(define xx ::int 1)
</pre>
<li><p><code>define-for-syntax</code> and <code>begin-for-syntax</code> work.</p></li>
<li><p><p>You can now use <code>car</code>, <code>cdr</code> etc to work with
<code>syntax</code> objects that wrap lists, as in SRFI-72.</p></li>
<li><p>You can now define a package alias:
<pre>
(define-alias jutil java.util)
(define mylist :: jutil:List (jutil:ArrayList))
</pre>
</li>
<li><p><code>--module-static</code> is now the default.
A new <code>--module-nonstatic</code> (or <code>--no-module-static</code>)
option can be used to get the old behavior.</p></li>
<li><p>You can use <code>access:</code> to specify that a field
is <code>'volatile</code> or <code>'transient</code>.</p></li>
<li><p>You can now have type-specifiers for multiple variables
in a <code>do</code>.</p></li>
<li><p>Imported variables are read-only.</p></li>
<li><p>Exported variables are only made into Locations when needed.</p></li>
<li><p>The letter used for the exponent in a floating-point literal
determines its type: <code>12s2</code> is a <code>java.lang.Float</code>, <code>12d2</code> is a <code>java.lang.Double</code>,
<code>12l2</code> is a <code>java.math.BigInteger</code>, <code>12e2</code> is a <code>gnu.math.DFloat</code>.</p></li>
<li><p>Internal: Asking for a <code>.class</code> file using
<code>getResourceAsStream</code> on an <code>ArrayClassLoader</code>
will now open a <code>ByteArrayInputStream</code> on the class bytes.</p></li>
<li><p>A new <code>disassemble</code> function.</p></li>
<li><p>If <code>exp1</code> has type <code>int</code>,
the type of <code>(+ exp1 1)</code> is now (32-bit) <code>int</code>,
rather than (unlimited-precision) <code>integer</code>.
Similar for <code>long</code> expressions, other arithmetic operations
(as appropriate), and other untyped integer literals
(as long as they fit in 32/64 bits respectively).</p></li>
<li><p>Many more oprimization/specializations of arithmetic, especially
when argument types are known.</p></li>
<li><p>Top-level bindings in a module compiled with <code>--main</code>
are now implicitly module-private, unless there is an explicit <code>module-export</code>.</p></li>
<li><p><a href="http://srfi.schemers.org/srfi-2/srfi-2.html">SRFI-2</a> (<code>and-let*</code>: an <code>and</code> with local bindings, a guarded <code>*</code> special form) is now supported.</p>
<li><p>The reader now supports shared sub-objects,
as in <a href="http://srfi.schemers.org/srfi-38/srfi-38.html">SRFI-38</a>
and Common Lisp: <code>(#2=(3 4) 9 #2# #2#)</code>.
(Writing shared sub-objects is not yet implemented.)</p>
<li><p>A module compiled with <code>--main</code> by default exports no
bindings (unless overriden by an explicit <code>module-export</code>).</p></li>
<li><p>Factor out compile-time only code from run-time code.
The new <code>kawart-<var>version</var>.jar</code>
is smaller because it has less compile-time only code.  (Work in progress.)
<li><p>More changes for R6RS compatibility:</p>
<ul>
<li><p>The reader now recognizes <code>+nan.0</code>,
<code>+inf.0</code> and variations.</p></li>
<li><p>The <code>div</code>, <code>mod</code>,
<code>div0</code>, <code>mod0</code>, <code>div-and-mod</code>,
<code>div0-and-mod0</code>, <code>inexact</code>
and <code>exact</code> functions were implemented.</p></li>
<li><p><code>command-line</code> and <code>exit</code>.</p></li>
</ul></li>
</ul>

<!--
<li><p>Kawa now by default generates a static module.
The default is <code>--module-static</code>
if <code>--main</code> is specified in the command-line,
and <code>--module-static-run</code> otherwise.</p></li>
-->
<h2>Kawa 1.9.90 (August 8, 2009)</h2>
<ul>
<li><p>Support for <code>javax.script</code>.</p></li>
<li><p>Support for <a href="Regular-expressions.html">regular expressions</a>.</p></li>
<li><p>Performance improvements:</p>
<ul>
<li><p>Emit <code>iinc</code> instruction (to increment a local
<code>int</code> by a constant).</p></li>
<li><p>Inline the <code>not</code> function if the argument is constant.</p></li>
<li><p>If <code>call-with-current-continuation</code> is only used to exit
a block in the current method, optimize to a <code>goto</code>.</p></li>
<li><p>Generate <code>StackMapTable</code> attributes when targeting Java 6.</p></li>
<li><p>Kawa can now inline a function with multiple calls (without
code duplication) if all call sites have the same return location
(continuation).  For example: <code>(if p (f a) (f b))</code>.
Also mutually tail-recursive functions are inlined, so you get constant
stack space even without <code>--full-tailcalls</code>.
(Thanks for Helmut Eller for a prototype.)</p</li>
</ul></li>
<li><p>A number of changes for R6RS compatibility:</p>
<ul>
<li><p>The <code>char-titlecase</code>, <code>char-foldcase</code>,
<code>char-title-case?</code> library functions are implemented.</p></li>
<li><p>Imported variables are read-only.</p></li>
<li><p>Support the R6RS <code>import</code> keyword, including
support for renaming.</p></li>
<li><p>Support the R6RS <code>export</code> keyword (though
without support for renaming).</p></li>
<li><p>Implemented the <code>(rnrs hashtables)</code> library.</p></li>
<li><p>Implemented the <code>(rnrs sorting)</code> library.</p></li>
<li><p>CommonLisp-style keyword syntax is no longer supported (for Scheme):
A colon followed by an identifier is no longer a keyword
(though an identifier followed by a colon is still a keyword).
(One reason for this change is to support SRFI-97.)</p></li>
<li><p>
The character names <code>#\delete</code>, <code>#\alarm</code>,
<code>#\vtab</code> are now supported.
The old names <code>#\del</code>,  <code>#\rubout</code>, and
<code>#\bel</code> are deprecated.</p></li>
<li><p>Hex escapes in character literals are supported.
These are now printed where we before printed octal escapes.</p></li>
<li><p>A hex escape in a string literal should be terminated by a semi-colon,
but for compatibily any other non-hex-digit will also terminate the escape.
(A terminating semi-colon will be skipped, though a different terminator
will be included in the string.)</p></li>
<li><p>A backslash-whitespace escape in a string literal will not only
ignore the whitespace through the end of the line, but also
any initial whitespace at the start of the following line.</p></li>
<li><p>The comment prefix <code>#;</code> skips the following
S-expression, as specified by
<a href="http://srfi.schemers.org/srfi-62/srfi-62.html">SRFI-62</a>.</p></li>
<li><p>All the <a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-12.html#node_sec_11.4">R6RS exact bitwise arithmetic</a> functions are
now implemented and <a href="Logical-Number-Operations.html">documented in the manual</a>.
The new standard functions (for example <code>bitwise-and</code>)
are now preferred over the old functions (for example <code>logand</code>).</p></li>
<li><p>If <code>delete-file</code> fails, throws an
exception instead of returning <code>#f</code>.</p></li>
</ul>
</li>
<li><p>The code-base now by default assumes Java 5 (JDK 1.5 or newer),
and pre-built <code>jar</code> files will require Java 5.
Also, the Kawa source code now uses generics, so you need to
use a generics-aware <code>javac</code>,
passing it the appropriate <code>--target</code> flag.</p></li>
<li><p>New SRFIs supported:</p>
<ul>
<li><p><a href="http://srfi.schemers.org/srfi-62/srfi-62.html">SRFI-62</a> - S-expression comments.</p></li>
<li><p><a href="http://srfi.schemers.org/srfi-64/srfi-64.html">SRFI-64</a> - Scheme API for test suites.</p></li>
<li><p><a href="http://srfi.schemers.org/srfi-95/srfi-95.html">SRFI-95</a> - Sorting and Merging.</p></li>
<li><p><a href="http://srfi.schemers.org/srfi-97/srfi-97.html">SRFI-97</a> - Names for SRFI Libraries.  This is a naming convention for R6RS
<code>import</code> statements to reference SRFI libraries.</p></li>
</ul></li>
<li><p>In BRL text outside square brackets (or nested like <code>]this[</code>)
now evaluates to <code>UnescapedData</code>, which a Scheme quoted string
evaluates to <code>String</code>, rather than an <code>FString</code>.
(All of the mentioned types implement <code>java.lang.CharSequence</code>.)</p></li>
<li><p>You can now <a href="http://per.bothner.com/blog/2009/AndroidHelloScheme/">run Kawa Scheme programs on Android</a>, Google's mobile-phone
operating system.</p></li>
<li><p>The macro <code>resource-url</code> is useful for accessing resources.</p></li>
<li><p>A new command-line option <code>--target</code> (or <code>-target</code>)
similar to <code>javac</code>'s <code>-target</code> option.</p></li>
<li><p>If there is no console, by default create a window
as if <code>-w</code> was specificed.</p></li>
<li><p>If a class method (defined in <code>define-class</code>,
<code>define-simple-class</code> or <code>object</code>) does not have
its parameter or return type specified, search the super-classes/interfaces
for matching methods (same name and number of parameters), and if these
are consistent, use that type.</p></li>
<li><p>Trying to modify the <code>car</code> or <code>cdr</code> of a
literal list now throws an exception.</p></li>
<li><p>The <code>.zip</code> archive created by <code>compile-file</code>
is now compressed.</p></li>
<li><p>Java5-style varargs-methods are recognized as such.</p></li>
<li><p>When evaluating or loading a source file, we now always
compile to bytecode, rather than interpreting <q>simple</q>
expressions.  This makes semantics and performance more consistent,
and gives us better exception stack traces.</p></li>
<li><p>The Scheme type specifier <code>&lt;integer&gt;</code>
now handles automatic conversion from <code>java.math.BigInteger</code>
and the <code>java.lang</code> classes <code>Long</code>,
<code>Integer</code>, <code>Short</code>, and <code>Byte</code>.
The various standard functions that work on <code>&lt;integer&gt;</code>
(for example <code>gcd</code> and <code>arithmetic-shift</code>)
can be passed (say) a <code>java.lang.Integer</code>.
The generic functions such as <code>+</code> and the real
function <code>modulo</code> should also work.
(The result is still a <code>gnu.math.IntNum</code>.)</p></li>
<li><p>If a name such as (<code>java.util</code>) is lexically
unbound, and there is a known package with that name, return the
<code>java.lang.Package</code> instance.  Also, the colon operator
is extended so that <code><var>package</var>:<var>name</var></code>
evaluates to the <code>Class</code> for
<code><var>package</var>.<var>name</var></code>.</p></li>
<li><p><code>`<var>prefix</var>:,<var>expression</var></code> works
- it finds a symbol in <code>prefix</code>'s package (aka namespace),
whose local-name is the value of <code>expression</code>.</p></li>
<li><p>A quantity <code>3.0cm</code> is now syntactic sugar for
<code>(* 3.0 unit:cm)</code>.
Similarly:<br />
<code>(define-unit <var>name</var> <var>value</var>)</code>
<br />
is equivalent to:
<br />
<code>(define-constant unit:<var>name</var> <var>value</var>)</code>
<br />
This means that unit names follow normal name-lookup rules
(except being in the <code>unit</code> <q>package</q>), so for example you can
have local unit definitions.</p></li>
<li><p>You can specify whether a class has
public or package access, and whether it is translated
to an interface or class.</p></li>
<li><p>You can declare an abstract method
by writing <code>#!abstract</code> as its body.</p></li>
<li><p>If a name of the form <code><var>type</var>?</code> is undefined,
but <code><var>type</var></code> is defined, then
treat the former as <code>(lambda (x) (instance? x <var>type</var>))</code>.
<li><p>A major incompatible (but long-sought) change:
Java strings (i.e. <code>java.lang.String</code> values) are
now Scheme strings, rather than Scheme symbols.
Since Scheme strings are mutable, while Java <code>String</code>s are
not, we use a different type for mutable strings:
<code>gnu.lists.FString</code> (this is not a change).
Scheme string literals are <code>java.lang.String</code> values.
The common type for Scheme string is <code>java.lang.CharSequence</code>
(which was introducted in JDK 1.4).</p>
<p>
Scheme symbols are now instances of <a href="api/gnu/mapping/Symbol.html"><code>gnu.mapping.Symbol</code></a>, specifically the <code>SimpleSymbol</code> class.
</li>
<li><p>A fully-qualified class name such as <code>java.lang.Integer</code>
now evaluates to the corresponding <code>java.lang.Class</code> object.
I.e. it is equivalent to the Java term <code>java.lang.Integer.class</code>.
This assumes that the name does not have a lexical binding,
<em>and</em> that it exists in the class-path at compile time.
<p>Array class names (such as <code>java.lang.Integer[]</code>)
and primitive types (such as <code>int</code>) also work.
<p>
The older angle-bracket syntax <code>&lt;java.lang.Integer&gt;</code>
also works and has the same meaning.
It also evaluates to a <code>Class</code>.
It used to evaluate to a <a href="api/gnu/bytecode/Type.html"><code>Type</code></a>, so this is a change.
<p>
The name bound by a <code>define-simple-class</code> now evaluates to a
<code>Class</code>, rather than a <a href="api/gnu/bytecode/ClassType.html"><code>ClassType</code></a>.  A <code>define-simple-class</code> is not allowed
to reference non-static module-level bindings; for that
use <code>define-class</code>.
</li>
<li><p>New convenience macro <a href="Syntax-and-conditional-compilation.html"><code>define-syntax-case</code></a>.</p></li>
</ul>

<h2>Kawa 1.9.1 (January 23, 2007)</h2>
<ul>
<li><p>Fix some problems building Kawa from
source using <code>configure+make</code>.</li>
</ul>

<h2>Kawa 1.9.0 (January 21, 2007)</h2>
<ul>
<li><p>New types and functions for working
with <a href="Paths.html">paths and URIs</a>.</p></li>
<li><p>Reader macros URI, namespace, duration.</p></li>
<li><p>Simplified <a href="Source-distribution.html">build using gcj</a>,
and added configure flag --with-gcj-dbtool.</p></li>
<li><p>If two <q>word</q> values are written, a space is written between them.
A word is most Scheme values, including numbers and lists.
A Scheme string is treated as a word by <code>write</code> but by not
<code>display</code>.</p></li>
<li><p>A new <code>--pedantic</code> command-line flag.
It currently only affects the XQuery parser.</p></li>
<li><p>The <code>load-compile</code> procedure was removed.</p></li>
<li><p>The string printed by the <code>--version</code> switch
now includes the Subversion revision and date
(but only if Kawa was built using <code>make</code> rather than <code>ant</code> from a checked-out Subversion tree).</p>
<li><p>
Kawa development now uses the <a href="http://subversion.tigris.org/">Subversion (svn)</a> version control system instead of CVS.</p></li>
<li><p>Show file/line/column on unbound symbols (both when interpreted and
when compiled).</p></li>
<li>
<p>Cycles are now allowed between <code>require</code>'d modules.
Also, compiling at set of modules that depend on each other can now
specified on the compilation command line in any order, as long as
needed <code>require</code> forms are given.</p></li>
<li><p>The <a href="PathExpressions.html"><q>colon notation</q> has been generalized.</a>.
The syntax <code><var>object</var>:<var>name</var></code>
generally means to extract a component with a given <code><var>name</var></code>
from <code><var>object</var></code>, which may be an object, a class,
or a namespace.</p>
<li><p>
New command-line options <code>--debug-error-prints-stack-trace</code>
and  <code>--debug-warning-prints-stack-trace</code> provide stack trace
on static error messages.</p></li>
<li>
<p>The 
<a href="Software-License.html">license for the Kawa software</a>
has been changed to the
<a href="http://opensource.org/licenses/mit-license.php">X11/MIT license</a>.
</p></li>
<li>
<p>A much more <a href="Array-operations.html">convenient syntax
for working with Java arrays</a>.</p>
<p>The same function-call syntax also works for Scheme vectors, uniform
vectors, strings, lists - and anything else that implements <code>java.util.List</code>.</p>
</li>
<li><p>
The fields and methods of a class and its bases classes are in scope
within methods of the class.
<li><p>
Unnamed procedures (such as lambda expressions) are printed
with the source filename and line.</p></li>
<li><p>The numeric compare functions (<code>=</code>, <code>&lt;=</code>, etc)
and <code>number->string</code> now work when passed standard Java
<code>Number</code> objects (such as <code>java.lang.Long</code>
or <code>java.math.BigDecimal</code>).
<li><p>
<a href="http://srfi.schemers.org/srfi-10/srfi-10.html">SRFI-10</a>
is now implemented, providing the <code>#,(name args ...)</code> form.
Predefined constructor <code>name</code>s so far are <code>URI</code>
and <code>namespace</code>.
The <code>define-reader-ctor</code> function is available
if you <code>(require 'srfi-10)</code>.</p></li>
<li><p>
A new <code>--script</code> option makes it easier to write
Unix shell scripts.</p></li>
<li><p>Allow general URLs for loading (including the <code>-f</code> flag),
compilation and <code>open-input-file</code>, if the
<q>file name</q> starts with a URL <q>scheme</q> like <code>http:</code>.</p>
<li><p>
Classes defined (<i>e.g.</i> with <code>define-simple-class</code>) in
a module can now mutually reference each other.
On the other hand, you can no longer <code>define-class</code> if the
class extends a class rather than an interface; you must use
<code>define-simple-class</code>.</p></li>
<li><p><code>KawaPageServlet</code> now automatically selects language.</p></li>
<li><p><code>provide</code> macro.</li>
<li><p><code>quasisyntax</code> and the convenience syntax <code>#`</code>,
from <a href="http://srfi.schemers.org/srfi-72/srfi-72.html">SRFI-72</a>.</li>
<li><p><code>define-for-syntax</code>, <code>syntax-source</code>,
<code>syntax-line</code>, and <code>syntax-column</code>,
for better compatibility with mzscheme.</li>
<li><p>
<a href="http://srfi.schemers.org/srfi-34/srfi-34.html">SRFI-34</a>
(Exception Handling for Programs), which implements
<code>with-exception-handler</code>, <code>guard</code>, and
<code>raise</code>, is now available,
if you <code>(require 'srfi-34)</code>.<br/>
Also, <a href="http://srfi.schemers.org/srfi-35/srfi-35.html">SRFI-35</a>
(Conditions) is available, if you <code>(require 'srfi-35)</code>.</li>
<li><p>
The <code>case-lambda</code> form from <a href="http://srfi.schemers.org/srfi-16/srfi-16.html">SRFI-16</a> is now implemented more efficiently.</p></li>
</ul>

<h2>Kawa 1.8 (October 18, 2005)</h2>
<p>
<a href="http://srfi.schemers.org/srfi-69/srfi-69.html">SRFI-69 <q>Basic hash tables</q></a> is now available, if you <code>(require 'hash-table)</code> or <code>(require 'srfi-69)</code>.
This is an optimized and Java-compatible port whose default
hash function calls the standard <code>hashCode</code> method.
<p>
A <code>define-simple-class</code> can now have one (or more)
explicit constructor methods.  These have the spcial name <code>*init*</code>.
You can call superclass constructors or sibling constructors
(<code>this</code> constructor calls) using the (admittedly verbose but
powerful) <code>invoke-special</code> form.
<p>
The <code>runnable</code> function creates
a <code>Runnable</code> from a <code>Procedure</code>.
It is implemented using the new class <code>RunnableClosure</code>,
which is now also used to implement <code>future</code>.
<p>
The <code>kawa</code> command can now be run <q>in-place</q> from
the build directory: <code><var>$build_dir</var>/bin/kawa</code>.
<p>
The special field name <code>class</code> in
<code>(static-name <var>type</var> 'class)</code> or
<code>(<var>prefix</var>:.class)</code> returns the <code>java.lang.Class</code>
object corresponding to the <code><var>type</var></code> or
<code><var>prefix</var></code>.  This is similar to the Java syntax.
<p>
Contructing an instance (perhaps using <code>make</code>) of a class
defined using <code>define-simple-class</code> in the current module
is much more efficient, since it no longer uses reflection.
(Optimizing classes defined using <code>define-class</code> is
more difficult.)
The constructor function defined by the
<code>define-record-type</code> macro is also optimized.
<p>You can now access instance methods using this short-hand:
<code>(*:<var>methodname</var> <var>instance</var> <var>arg</var> ...)</code><br />
This is equivalent to:
<code>(invoke <var>instance</var> '<var>methodname</var> <var>arg</var> ...)</code>
<p>
You can now also access a fields using the same colon-notation as used for
accessing methods, except you write a dot before the field name:<br />
<code>(<var>type</var>:.<var>fieldname</var>)</code>
<code> ;; </code>is like: <code>(static-field <var>type</var> '<var>fieldname</var>)</code>.<br />
<code>(*:.<var>fieldname</var> <var>instance</var>)</code>
<code>;;</code> is like: <code>(field '<var>fieldname</var> <var>instance</var>)</code><br />
<code>(<var>type</var>:.<var>fieldname</var> <var>instance</var>)</code>
<code>;;</code> is like: <code>(*:.<var>fieldname</var> (as <var>instance</var> <var>type</var>))</code><br />
These all work with <code>set!</code> - for example:
<code>(set! (*:.<var>fieldname</var> <var>instance</var>) <var>value</var>)</code>.
<p>
In the above uses of colon-notation, a <code><var>type</var></code> can
be any one of:<br />
- a namespace prefix bound using <code>define-namespace</code> to a namespace
uri of the form <code>"class:<var>classname</var>"</code>;<br />
- a namespace prefix  using <code>define-namespace</code> bound to a <code>&lt;<var>classname</var>&gt;</code> name, which can be
  a fully-qualified class name or a locally-declared class, or an alias
  (which might be an imported class); <br />
- a fully qualified name of a class (that exists at compile-time),
  as in <code>(java.lang.Integer:toHexString 123)</code>; or<br />
- a <code>&lt;classname&gt;</code> variable, for example: <code>(&lt;list&gt;:list3 11 12 13)</code>.
<p>
New fluid variables <code>*print-base*</code>, <code>*print-radix*</code>,
<code>*print-right-margin*</code>, and <code>*print-miser-width*</code>
can control output formatting.  (These are based on Common Lisp.)
<p>
You can new emit elipsis (<code>...</code>) in the output of a
<code>syntax</code> template using the syntax <code>(... ...)</code>,
as in other <code>syntax-case</code> implementations.</p>
<p>
The <code>args-fold</code> program-argument processor from
<a href="http://srfi.schemers.org/srfi-37/srfi-37.html">SRFI-37</a>
is available after you <code>(require 'args-fold)</code> or <code>(require 'srfi-37)</code>.</p>
<p>
The <code>fluid-let</code> form now works with lexical bindings, and should
be more compatible with other Scheme implementations.</p>
<p>
<code>(module-export namespace:<var>prefix</var>)</code> can be used to export a namespace prefix.
<p>
Static modules are now implemented more similarly to non-static modules.
Specifically, the module body is not automatically run by the class
initializer.
To get the old behavior, use the new <code>--module-static-run</code> flag.
Alternatively, instead of <code>(module-static #t)</code> use
<code>(module-static 'init-run)</code>.
<p>
Implement <a href="http://srfi.schemers.org/srfi-39/srfi-39.html">SRFI-39</a>
"Parameter-objects".  These are like anonymous
fluid values and use the same implementation.
<code>current-input-port</code>, <code>current-output-port</code>,
and <code>current-error-port</code> 
are now parameters.
<p>
Infer types of variables declared with a <code>let</code>.
<p>
Character comparisons (such as <code>char-=?</code>, <code>char-ci&lt;?</code>)
implemented
much more efficiently &mdash; and (if using Java5) work for characters not
in the Basic Multilingual Plane.
<p>
Major re-write of symbol and namespace handling.
A <a href="api/gnu/mapping/Symbol.html"><code>Symbol</code></a> is now
immutable,
consisting of a "print-name" and a pointer to
a <a href="api/gnu/mapping/Namespace.html"><code>Namespace</code></a> (package).
An <a href="api/gnu/mapping/Environment.html"><code>Environment</code></a>
is a mapping from <code>Symbol</code>
to <a href="api/gnu/mapping/Location.html"><code>Location</code></a>.
<p>
Rename <code>Interpreter</code>
to <a href="api/gnu/expr/Language.html"><code>Language</code></a> and
<code>LispInterpreter</code>
to <a href="api/gnu/kawa/lispexpr/LispLanguage.html"><code>LispLanguage</code></a>.
<p>
Constant-time property list operations.
<p>
Namespace-prefixes are now always resolved at compile-time, never at run-time.
<p>
<code>(define-namespace PREFIX &lt;CLASS&gt;)</code> is loosely the same as
<code>(define-namespace PREFIX "class:CLASS")</code> but does the right thing
for classes defined in this module, including nested or non-simple classes.
<p>
Macros capture proper scope automatically, not just when using require.
This allows some internal macros to become private.
<p>
Major re-write of the macro-handling and hygiene framework.
Usable support for <code>syntax-case</code>; in fact some of the primitives
(such as
<code>if</code>) are now implemented using <code>syntax-case</code>.
<code>(syntax <var>form</var>)</code> (or the
short-cut <code>#!<var>form</var>)</code> evaluates to a syntax object.
<code>(define-syntax (mac x) tr)</code>
same as <code>(define-syntax mac (lambda (x) tr))</code>.
The following non-hygienic forms are equivalent:
<pre>
  (define-macro (<var>macro-name</var> (<var>param</var> ...) <var>transformer</var>)
  (define-macro <var>macro-name</var> (lambda (<var>param</var> ...) <var>transformer</var>))
  (defmacro <var>macro-name</var> (<var>PARAM</var> ...) <var>transformer</var>)
</pre>
Allow vectors and more general ellipsis-forms in patterns and templates.
<p>
A new configure switch <code>--with-java-source=<var>version</var></code>
allows you to tweak
the Kawa sources to match Java compiler and libraries you're using.
The default (and how the sources are distributed)
is <code>2</code> (for "Java 2" &ndash; jdk 1.2 or better),
but you can also select "<code>1</code>" (for jdk 1.1.x), and
"<code>5</code>" for Java 5 (jdk 1.5).  You can also specify a jdk version number:
"<code>1.4.1</code>" is equivalent to "2" (for now). Note the default source-base
is incompatible with Java 5 (or more generally JAXB 1.3 or DOM 3),
unless you also <code>--disable-xml</code>.
<p>
Configure argument <code>--with-servlet</code>[<code>=servlet-api.jar</code>] replaces <code>--enable-servlet</code>.
<p>
Function argument in error message are now numbered starting at one.
Type errors now give better error messages.
<p>
A new function calling convention, used for <code>--full-tailcalls</code>.
A function call is split up in two parts:  A <code>match0</code>/.../<code>matchN</code>
method checks that the actual arguments match the expected
formal arguments, and leaves them in the per-thread
<a href="api/gnu/mapping/CallContext.html"><code>CallContext</code></a>.
Then after the calling function returns, a zero-argument <code>apply()</code>
methods evaluates the function body.  This new convention has
long-term advantages (performance, full continuations), but the
most immediate benefit is better handling of generic (otherloaded)
functions.  There are also improved error messages.
<p>
Real numbers, characters, Lisp/Scheme strings
(<a href="api/gnu/lists/FString.html"><code>FString</code></a>) and symbols
all now implement the <code>Comparable</code> interface.
<p>
In <code>define-class</code>/<code>define-simple-class</code>:
[Most of this work was funded by <a href="http://www.mercedsystems.com/">Merced Systems</a>.]
<ul>
<li> You can specify <code>access: </code>[<code>'private</code>|<code>'protected</code>|<code>'publi</code>c|<code>'package</code>] to set
  the Java access permissions of fields and methods.
<li> Methods can be static by using the <code>access: 'static</code> specifier.
<li> The reflective routines <code>invoke</code> , <code>field</code> ,
<code>static-field</code> , <code>slot-ref</code> , <code>slot-set!</code> 
can now access non-public methods/fields when appropriate.
<li> Such classes are no longer initialized when the containing module is loaded.
<li> The <code><var>expr</var></code> in
<code>init-form: <var>expr</var></code> is now evaluated in the outer scope.
<li> A new <code>init: <var>expr</var></code> evalues <code><var>expr</var></code> in the inner scope.
<li> An option name following <code>allocation:</code> can now be a string literal or a
  quoted symbol.  The latter is preferred:  <code>allocation: 'class</code>.
<li>
  Added <code>'static</code> as a synonym for <code>'class</code> following <code>allocation:</code>.
<li> Initialization of static field (<code>allocation: 'class init: <var>expr</var></code>) now
  works, and is performed at class initialization time.
<li> You can use unnamed <q>dummy fields</q> to add initialization-time actions
  not tied to a field:
<pre>
  (define-simple-class Foo ()
    (:init (perform-some-action)))
</pre>
</ul>

<h2>Kawa 1.7.90 (2003)</h2>
<p>
Various fixes and better error messages in number parsing.
Some optimizations for the divide function.
<p>
New framework for controlling compiler warnings and other features,
supporting command-line flags, and the Scheme forms <code>with-compile-options</code>
and <code>module-compile-options</code>.  The flag <code>--warn-undefined-variable</code> is
useful for catching typos.  Implementation funded by <a href="http://www.mercedsystems.com/">Merced Systems</a>.
<p>
New <code>invoke-special</code> syntax form (implemented by Chris Dean).
<p>
New <code>define-variable</code> form (similar to Common Lisp's <code>defvar</code>).

<h2>Kawa 1.7 (June 7, 2003)</h2>
<p>
<a href="api/gnu/kawa/servlet/KawaPageServlet.html"><code>KawaPageServlet</code></a> allows automatic loading and on-the-fly compilation in a
servlet engine.  See <a href="../qexo/simple-xquery-webapp.html">http://www.gnu.org/software/qexo/simple-xquery-webapp.html</a>.
<p>
The default source-base requires various Java 2 features, such as collection.
However, <code>make-select1</code> will comment out Java2 dependencies, allowing you
to build Kawa with an older Java implementation.
<p>
The <code>-f</code> flag and the load function can take an absolute URL.
New Scheme functions <code>load-relative</code> and <code>base-uri</code>.
<p>
Imported implementation of cut and cute from
<a href="http://srfi.schemers.org/srfi-26/srfi-26.html">SRFI-26</a>
(Notation for Specializing Parameters without Currying).
<p>
The way top-level definitions (including Scheme procedures) are mapped
into Java fields is changed to use a mostly reversible mapping.
(The mapping to method names remains more natural but non-reversible.)
<p>
<code>define-alias</code> of types can now be exported from a module.
<p>
New <code>--no-inline</code> and <code>--inline=none</code> options.
<p>
You can use <code>define-namespace</code> to define <q>namespace aliases</q>.
This is used for the new short-hard syntax for method invocation:<br />
<code>(define-namespace Int32 "class:java.lang.Integer")</code><br />
<code>(Int32:toHexString 255)</code> => <code>"ff"</code><br />
<code>(Int32:toString (Int32:new "00255"))</code> => <code>"255"</code><br />
Alternatively, you can write:<br />
<code>(java.lang.Integer:toHexString 255)</code> => <code>"ff"</code>
<p>
<a href="http://srfi.schemers.org/srfi-9/srfi-9.html">SRFI-9</a> (define-record-type) has been implemented, and compiled to a
<code>define-class</code>, with efficient code.
<p>
The configure option <code>--with-collections</code> is now the default.
<p>
Unknowns are no longer automatically static.
<p>
If type not specified in a declaration, don't infer it from it initial value.
If no return type is specified for a function, default to <code>Object</code>,
rather than the return type of the body.  (The latter leads to
undesirable different behaviour if definitions are re-arranged.)
<p>
You can now define and use classes defined using <code>object</code>,
<code>define-class</code>, and <code>define-simple-class</code>
from the <q>interpreter</q>, as well as the compiler.
Also, a bug where inherited fields did not get initialized has been fixed.
<p>
There are several new procedures useful for servlets.
<p>
Numerical comparisions (<code>&lt;</code>, <code>&lt;=</code>, etc) now generates optimized bytecode
if the types of the operands have certain known types. including
efficient code for <code>&lt;int&gt;</code>, <code>&lt;long&gt;</code>, <code>&lt;double&gt;</code>, and <code>&lt;integer&gt;</code>.
Much more code can now (with type declaration) be written just as
efficiently in Scheme as in Java.
<p>
There have been some internal re-arranging of how Expressions are
processed.  The Scheme-specific Translator type now inherits from
Compilation, which replaces the old Parser class.  A Complation is now
allocated much earlier, as part of parsing, and includes a
SourceMessages object.  SourcesMessages now includes (default) line
number, which is used by Compilation for the "current" line numbers.
The ExpWalker class includes a SourceMessages instance (which it gets
from the Compilation).  CanInline.inline method now takes ExpWalker
parameter.  Checking of the number or parameters, and mapping known
procedures to Java methods are now both done during the inlining pass.
<p>
The user-visible effect is that Kawa can now emit error mesages more
cleanly more places;  the inlining pass can be more agressive, and
can emit better error messages, which yields better type information.
This gives us better code with fewer warnings about unknown methods.

<h2>Changes from Kawa 1.6.98 to 1.6.99.</h2>
<p>
A new language front-end handles a tiny subset of XSLT.
An example is the check-format-users test in gnu/xquery/testsuite/Makefile.
<p>
There are now converters between SAX2 and Consumer events, and a basic
implementation of XMLReader based on XMLParser.
<p>
The function as-xml prints a value in XML format.
<p>
Srfi-0 (cond-expand), srfi-8 (receive), and srfi-25 (multi-dimensional
arrays) are now implemented.  So is srfi-1 (list library), though that
requires doing (require 'list-lib).
<p>
The JEmacs code is being re-organized, splitting out the Swing-dependent
code into a separate gnu.jemacs.swing package.  This should make it
easier to add JEmacs implementation without Swing.
<p>
The class gnu.expr.Interpreter has various new 'eval' methods that
are useful for evaluating Scheme/BRL/XQuery/... expressions from Java.
<p>
Kawa now uses current versions of autoconf, autoamke, and libtool,
allowing the use of automake file inclusion.
<p>
The comparisons <code>&lt;<</code>, <code>&lt;=</code>, <code>-</code>, <code>&gt;</code>, and <code>=&gt;</code> now compile to optimized Java
arithmetic if both operands are <code>&lt;int&gt;</code> or a literal that fits in <code>&lt;int&gt;</code>.

<h2>Changes from Kawa 1.6.97 to 1.6.98</h2>
<p>
Generated HTML and Postscrpt documents are no longer included in the
source distribution.  Get <code>kawa-doc-<var>version</var>.tar.gz</code> instead.
<p>
(format #t ...) and (format PORT ...) now returns #!void instead of #t.
<p>
Support fluid bindings (fluid-let) for any thread, not just Future and main.
<p>
A Unix script  header <code>#!/PROGRAM</code> is ignored.
<p>
You can now take the same Kawa "web" program (written in Scheme, KRL/BRL,
or XQuery) and run it as either a servlet or a CGI script.
<p>
There are a number of new functions for accessing HTTP requests and
generating HTTP responses.
<p>
Kawa now supports a new experimental programming KRL (the "Kawa Report
Language").  You select this language using --krl on the Kawa command
link.  It allows Scheme code to be inside template files, like HTML
pages, using a syntax based on BRL (brl.sourceforge.net).  However,
KRL has soem experimental changes to both BRL and standard Scheme.
There is also a BRL-compatibile mode, selected using --brl, though
that currently only supports a subset of BRL functions.
<p>
If language is not explicitly specified and you're running a source
file (e.g. "java kawa.repl myscript.xql"), Kawa tried to derive the
language from the the filename extension (e.g. "xql").  It still defaults
to Scheme if there is no extension or the extension is unrecognized.
<p>
New command-line option --output-format alias --format can be used to
over-ride the format used to write out top-level (repl, load) values.
<p>
XMLPrinter can now print in (non-well-formed-XML) HTML.

<h2>Changes from Kawa 1.6.96 to 1.6.97</h2>
<p>
Changed lots of error messages to use pairs of single quotes rather
than starting with a backquote (accent grave):  'name' instead of `name'.
Many newer fonts make the latter look bad, so it is now discouraged.
<p>
The types <code>&lt;String&gt;</code> and <code>&lt;java.lang.String&gt;</code> new behave differently.  The
type <code>&lt;java.lang.String&gt;</code> now works just like (say) <code>&lt;java.util.Hashtable&gt;</code>.
Converting an object to a <code>&lt;java.lang.String&gt;</code> is done by a simple
coercion, so the incoming value must be a java.lang.String reference
or null.  The special type <code>&lt;String&gt;</code> converts any object to a 
java.string.String by calling toString; it also handles null by
specially testing for it.
<p>
For convenience (and backwards compatibility) Kawa uses the type
<code>&lt;String&gt;</code> (rather than <code>&lt;java.lang.String&gt;</code>) when it sees the Java
type <code>java.lang</code>.String, for example in the argument to an <code>invoke</code>.
<p>
The default behaviour of '[' and '] was changed back to be token
(word) constituents, matching R5RS and Common Lisp.  However, you
can easily change this behaviour using the new setBrackMode method
or the defaultBracketMode static field in ReadTable.
<p>
You can now build Kawa from source using the Ant build system (from
Apache's Jakarta project), as an alternative to using the traditional
configure+make system.  An advantage of Ant is that it works on
most Java systems, without requiring a Unix shell and commands.
Specifically, this makes it easy to build Kawa under MS-Windows.
Thanks to James White for contributing this support.
<p>
Added (current-error-port) which does the obvious.
<p>
The new let-values and let-values* macros from srfi-11 provide a
more convenient way to use multiple values.
<p>
All the abstract apply* and eval* methods now specify 'throws Throwable'.
A bunch of code was changed to match.  The main visible advantage is
that the throw and primitive-throw procedures work for any Throwable
without requiring it to be (confusingly) wrapped.

<h2>Changes from Kawa 1.6.95 to 1.6.96</h2>
<p>
A new compilation flag --servlet generates a Servlet which can be
deployed in a servlet engin like Tomcat.  This is experimental,
but it seesm to work for both Scheme source and XQuery source.
<p>
The interface gnu.lists.CharSequence was renamed to avoid conflitcs
with the (similar) interface java.lang.CharSequence in JDK 1.4beta.
<p>
New --help option (contributed by Andreas Schlapbach).
<p>
Changed the code generation used when --full-tailcalls.  It now is
closer to that used by default, in that we don't generate a class for
each non-inlined procedure.  In both cases calling an unknown
procedure involves executing a switch statement to select a method.
In addition to generating fewer classes and simplifying one of the
more fragile parts of Kawa, it is also a step towards how full
continuations will be implemented.
<p>
Changed the convention for name "mangling" - i.e. how Scheme names are
mapped into Java names.  Now, if a Scheme name is a valid Java name it
is used as is; otherwise a reversible mangling using "$" characters is
used.  Thus the Scheme names <code>'&lt;</code> and <code>'$Leq</code> are
both mapped into the same Java name <code>"$Leq"</code>.
However, other names not containing "<code>$</code>" should
no longer clash, including pairs like "<code>char-letter?</code>" and
"<code>charLetter?</code>"
and "<code>isCharLetter</code>" which used to be all mapped to
"<code>isCharLetter</code>".  Now
only names containing "<code>$</code>" can be ambiguous.
<p>
If the compiler can determine that all the operands of (+ ...)  or
(- ...) are floating-point, then it will generate optimized code using
Java primitive arithmetic.
<p>
Guile-style keyword syntax '#:KEYWORD' is recognized.
(Note this conflicts with Common Lisp syntax for uninterned symbols.)
<p>
New syntax forms define-class and define-simple-class allow you to
define classes more easily.  define-class supports true multiple
inheritance and first class class values, where each Scheme class
is compiled to a pair of an inteface and a class.  define-simple-class
generates more efficient and Java-compatible classes.

<h2>Changes from Kawa 1.6.94 to 1.6.95.</h2>
<p>
A new language "xquery" implements a (so far small subset of) XQuery,
the draft XML Query languaage.
<p>
Various internal (Java API) changes:  Changes to gnu.expr.Interpreter
to make it easier to add non-Lisp-like languages;  gnu.lists.Consumer
now has an endAttribute method that need to be called after each
attribute, rather than endAttributes that was called after all of them.
<p>
If configured with --with-gcj, Kawa builds and intalls a 'gckawa' script
to simlify linking with needed libraries.
<p>
The <code>setter</code> function is now inlined, and
<code>(set! (field X 'N) V)</code> and
<code>(set! (static-field &lt;T&gt; "N) V)</code> are now inlined.
<p>
If configured <code>--with-gcj</code>, then a <code>gckawa</code> helper
script is installed, to make it easier to link Kawa+gcj-compiled applications.

<h2>Changes from Kawa 1.6.92 to 1.6.94</h2>
<p>
The JEmacs code now depends on CommonLisp, rather than vice versa, which
means Commonlisp no longer depends on Swing, and can be built with GCJ.
CommonLisp and JEmacs symbols are now implemented using Binding, not String.

<h2>Changes from Kawa 1.6.90 to 1.6.92</h2>
<p>
Kawa now installs as a .jar file (kawa.jar symlinked to kawa-VERSION.jar),
rather than a collection of .class files.
<p>
The Kawa manual includes instructions for how to build Kawa using GCJ,
and how to compile Scheme code to a native executable using GCJ.
<p>
Kawa now has builtin pretty-printer support, using an algorithm from
Steel Bank Common Lisp converted from Lisp to Java.  The high-level
Common Lisp pretty-printing features are mostly not yet implemented,
but the low-level support is there.  The standard output and error
ports default to pretty-printing.
<p>
A new formatting framework uses the Consumer interface from gnu.lists.
You can associate a format with an output port.  Common Lisp and JEmacs
finally print using their respective syntaxes.
<p>
All output ports (OutPort instances) are now automatically flushed on
program exit, using a new WriterManager helper class.
<p>
The new commmand-line option --debug-print-expr causes the Expression
for each expression to be printed.  The option --debug-print-final-expr
is similar, but prints Expressions after optimization and just before
compilation.  They are printed using the new pretty-printer.
<p>
Changed calling convention for --full-tailcalls to write results
to a Consumer, usually a TreeList or something to be printed.
A top-level ModuleBody now uses the same CpsProcedure convention.
This is useful for generating xml or html.
<p>
New libtool support allows kawa to be built as a shared library.
<p>
The new configure flag --with-gcj uses gcj to compile
Kawa to both .class files and native code.  This is experimental.

<h2>Changes from Kawa 1.6.70 to 1.6.90</h2>
<p>
The reader (for Scheme and Lisp) has been re-written to be table-driven,
based on the design of Common Lisp readtables.
<p>
The new gnu.lists package has new implementations of sequence-related
classes.  It replaces most of gnu.kawa.util.  See the package.html file.
<p>
If the expected type of a non-unary <code>+</code> or <code>-</code> is <code>&lt;int&gt;</code> or <code>&lt;long&gt;</code> and
the operands are integeral types, then the operands will converted to
the primitive integer type and the addition or subtraction done
using primitive arithmetic.  Similarly if the expected type is <code>&lt;float&gt;</code>
or <code>&lt;long&gt;</code> and the operands have appropriate type.  This optimization
an make a big performance difference.  (We still need to also optimize
compare operations like <code>(&lt; x y)</code> to really benefit from <code>&lt;int&gt;</code> declarations
of loop variables.)
<p>
The implementation of procedure closures has been changed to basically
be the same as top-level procedures (except when --full-tailcalls is
specified):  Each procedure is now an instance of a ModuleMethod,
which each "frame" is an instance of ModuleBody, just like for
top-level functions.  This sometimes reduces the number of classes
generated, but more importantly it simplifies the implementation.
<p>
A new <a href="api/gnu/xml/package-summary.html"><code>gnu.xml</code></a> package contains XML-related code, currently an XML
parser and printer, plus some XPath support.  The class
<a href="api/gnu/lists/TreeList.html"><code>gnu.lists.TreeList</code></a>
(alias <code>&lt;document&gt;</code>) is useful for compactly
representing nested structures, including XML documents.
If you <code>(require 'xml)</code> you will get Scheme interfaces
(<code>print-as-xml</code> and <code>parse-xml-from-url</code>) to
these classes.
<p>
New package gnu.kawa.functions, for primitive functions (written in Java).
<p>
The map and for-each procedure is now inlined.  This is most especially
beneficial when it allows the mapped-over procedure to also be inlined,
such as when that procedure is a lambda expression.
<p>
Added documentation on compiling with Jikes.
Renamed some classes to avoid warning when compiling with Jikes.
<p>
The reverse! procedure was added.
<p>
Internal changes:
* If a variable reference is unknown, create a Declaration
instance with the IS_UNKNOWN flag to represent an imported binding.
* The ExpWalker framework for "tree walking" Expressions had a bit of
reorganization.
* New package gnu.kawa.functions, for primitive functions (written in Java).
<p>
Added a hook for constant-folding and other optimization/inlining at
traversal (ExpWalker) time.  Optimization of + and - procedures to
use primitive Java operations when the operands are primitive types.
<p>
Implementation of SRFI-17.  Change the definitions of
(set! (f x ...) val) to ((setter f) x ... val), rather then
the old ((setter f) val x ...).  You can now associate a setter
with a procedure, either using make-procedure or set-procedure-property!.
Also, (setter f) is now inlined, when possible.
<p>
Internally, Syntax (and hence Macro) no longer extend Declaration.
<p>
Various Java-level changes, which may be reflected in Scheme later:
* gnu.kawa.util.Consumer interface is similar to ObjectOutput
and SAX's ContentHandler interfaces.
* A gnu.expr.ConsumerTarget is used when evaluating to an implicit Consumer.
* These interfaces will make it easy to write functional-style but efficient
code for transforming data streams, including XML.
* gnu.kawa.util.FString is now variable-size.

<h2>Changes from Kawa 1.6.68 to 1.6.70</h2>
<p>
The bare beginnings of Common Lisp support, enabled by the --commonlisp
(or --clisp) command line option.  This is so far little more than a
hack of the EmacsLisp support, but with lexical scoping and CL-style format.

<h2>Changes from Kawa 1.6.66 to 1.6.68</h2>
<p>
JEmacs news:
<ul>
<li> Define emacs-version as Kawa version but with leading 0 instead of 1.
For example, the current value is "0.6.68 JEmacs".
<li> New testsuite directory.
<li> Improved autoload framework.  Handle ELisp autoload comments.
<li> Handle escape and meta-key.
<li> Handle lot more of ELisp.
<li> Lots more is now done in ELisp, using .el files imported from XEmacs.
<li> Incomplete support for setting mark, including using selection.
<li> Basic (but incomplete) implementation of (interactive spec).
<li> Common Lisp extensions: typep, default arguments.
<li> A new status.html file to note what works and what doesn't.
</ul>
<p>
You can now specify in <code>define</code> and <code>define-private</code> the
type of a variable.  If the variable is module-level,
<code>(define name :: &lt;type&gt; value)</code> creates a field named
<q><code>name</code></q>
having the specified type and initial value.  (If type is not
specified, the default is not <code>Object</code>,
but rather a <code>Binding</code>
that <em>contains</em> the variable's value.)
<p>
You can now define the type of a module-level variable:  In
(define[-private] :: type expression)
New (define-constant name [:: type] expression) definition form.
<p>
A procedure can now have arbitrary properties associated with it.
Use procedure-property and set-procedure-property! to get and set them.
<p>
The new procedure make-procedure creates a generic procedure that
may contain one or more methods, as well as specified properties.
<p>
New declaration form define-base-unit.  Both it and define-unit have been
re-implemented to be module-safe.  Basically '(define-unit ft 12in)'
is sugar for '(define-constant ft$unit (... (* 12 in$unit)))', where
ft$unit and in$unit are standard identifiers managed by the module
system.  Also, the output syntax for units and quantities is cleaner.
<p>
The new declaration (module-export name ...) allows control over the
names exported from a module.  The new declaration (module-static ...)
allows control over which definitions are static and which are
non-static.  This makes it easier to use a module as a Java class.
<p>
Procedures names that accidentally clash with inherited method
names (such as "run") are now re-named.
<p>
Simple aliases (define-aliases defining an alias for a variable name)
are implemented more efficiently.
<p>
The package hierarchy is getter cleaner, with fewer cyclic dependencies:
The gnu.math package no longer has any dependencies on kawa.* or gnu.*.
Two classes were moved from gnu.text to other classes, avoiding another
cyclic package dependency between gnu.text and gnu.mapping.  The new
gnu.kawa.lispexpr is for compile-time handling of Lisp-like languages.
<p>
Compliation of literals has been re-done.  A class that can be used
in a literal no longer needs to be declared as Compilable.  Instead,
you declare it as implementaing java.io.Externalizable, and make
sure it has appropriate methods.
<p>
All the standard "data" types (i.e. not procedures or ports) now
implement java.io.Externalizable, and can thus be serialized.
If they appear in literals, they can also be compiled.
<p>
Created a new class gnu.kawa.util.AbstractString, with the Scheme
alias <code>&lt;abstract-string&gt;</code>.  The old gnu.kawa.util.FString now
extends AbstractString.  A new class CharBuffer provides an
growable buffer, with markers (automatically-adjusted positions).
Many of the Scheme <code>&lt;string&gt;</code> procedures now work
on <code>&lt;abstract-string&gt;</code>.
The JEmacs BufferContnat class (contains the characters of a buffer)
now extends CharBuffer.
<p>
Some JEmacs changes to support a "mode" concept, as well as
preliminary support for inferior-process and telnet modes.
<p>
New section in manual / web page for projects using Kawa.
<p>
The record feasture (make-record-type etc) how handles "funny" type
and fields names that need to be "mangled" to Java names.
<p>
Re-did implementation of define-alias.  For example, you can
define type-aliases:<br />
<code>(define-alias &lt;marker&gt; &lt;gnu.jemacs.buffer.Marker&gt;)</code>
<br />and then use &lt;marker&gt; instead of &lt;gnu.jemacs.buffer.Marker&gt;.
<p>
<code>(field <var>array</var> 'length)</code> now works.

<h2>Changes from Kawa 1.6.64 to 1.6.66</h2>
<p>
Added documentation to the manual for Homogeneous numeric vector datatypes
(SRFI-4).
<p>
You can now specify characters using their Unicode value:  #\u05d0 is alef.
<p>
Kawa now uses a more mnemonic name mangling Scheme.  For example,
a Scheme function named <code>&lt;=</code> would get compiled to
method <code>$Ls$Eq</code>.
<p>
There is now working and useful module support, thought not all
features are implemented.  The basic idea is that a module can be any
class that has a default constructor (or all of whose fields and
methods are static);  the public fields and methods of such a
class are its exported definitions.  Compiling a Scheme file
produces such a module.  Doing:<br/>
<code> (require &lt;classname&gt;)</code>
<br/>
will create an anonymous instance of <code>&lt;classname&gt;</code> (if needed), and add
all its exported definitions to the current environment.  Note that if
you import a class in a module you are compiling, then an instance of
the module will be created at compile-time, and imported definitions
are not re-imported.
(For now you must compile a module, you cannot just load it.)
<p>
The define-private keyword creates a module-local definition.
<p>
New syntax to override some properties of the current module:<br/>
<code>(module-name &lt;<var>name</var>&gt;)</code> overrides the default name for a module.<br/>
<code>(module-extends &lt;<var>class</var>&gt;)</code> specifies the super-class.<br/>
<code>(module-implements &lt;<var>interface</var>&gt; ...)</code> specfies the implemented interfaces.
<p>
The syntax:
	(require 'keyword)
is syntactic sugar for (require &lt;classname&gt;) where the classname
is find is a "module catalog" (currently hard-wired).
This provides compatibility with Slib.  The Slib "features"
gen-write, pretty-print, pprint-file, and printf are now
available in Kawa;  more will be added, depending on time and demand.
See the package directory gnu/kawa/slib for what is available.

<h2>Changes from Kawa 1.6.62 to 1.6.64</h2>
<p>
A lot of improvements to JEmacs (see JEmacs.SourceForge.net).
<p>
kawa-compiled-VERSION.zip is replaced by kawa-compiled-VERSION.jar.
<p>
You can now use Kawa to generate applets, using the new --applet switch,
Check the "Applet compilation" section in the manual.
Generating an application using the --main flag should work again.
Neither --applet nor --main has Scheme hard-wired any more.
<p>
A new macro `(this)' evaluates to the "this object" - the current instance
of the current class.  The current implementation is incomplete, and buggy,
but it will have to do for now.
<p>
The command-line argument -f FILENAME will load the same files types as load.
<p>
When a source file is compiled, the top-level definitions (procedures,
variables, and macros) are compiled to final fields on the resulting class.
This are not automatically entered into the current environment;  instead
that is the responsibility of whoever loads the compiled class.  This
is a major step towards a module system for Kawa.
<p>
There is a new form define-private which is like define, except that
the defined name is not exported from the current module.
<p>
A procedure that has optional arguments is now typically compiled into
multiple methods.  If it's a top-level procedure, these will be methods
in the modules "ModuleBody" class, with the same (mangled) name.
The compiler can in many cases call the appropriate method directly.
Usually, each method takes a fixed number of arguments, which means
we save the overhead of creating an array for the arguments.
<p>
A top-level procedure declared using the form
	(define (NAME ARS ...) BODY ..)
is assumed to be "constant" if it isn't assigned to in the current
compilation unit.  A call in the same compilation unit will now be
implemented as a direct method call.  This is not done if the
prcedure is declared with the form:
	(define NAME (lambda (ARGS ,,,) BODY ...)
<p>
gnu.expr.Declaration no longer inherits from gnu.bytecode.Variable.
<p>
A gnu.mapping.Environment now resolves hash index collisions using
"double hashing" and "open addressing" instead of "chaining" through
Binding.  This allows a Binding to appear in multiple Environments.
<p>
The classes Sequence, Pair, PairWithPosition, FString, and Char were
moved from kawa.lang to the new package gnu.kawa.util.  It seems that
these classes (except perhaps Char) belong together.  The classes List
and Vector were also moved, and at the same time renamed to LList and
FVector, respectively, to avoid clashed with classes in java.util.
<p>
New data types and procedures for "uniform vectors" of primitive types
were implemented.  These follow the SRFI-4 specification, which you
can find at http://srfi.schemers.org/srfi-4/srfi-4.html .
<p>
You can now use the syntax <code><var>name</var> :: <var>type</var></code> to specify the type of a parameter.
For example:
<br />
<code>(define (vector-length x :: &lt;vector&gt;) (invoke x 'length))</code>
<br/>
The following also works:<br />
<code>(define (vector-length (x :: &lt;vector&gt;)) ...)</code>.
<p>
<code>(define-member-alias <var>name</var> <var>object</var> [<var>fname</var>])</code> is new syntactic sugar
for <code>(define-alias <var>name</var> (field <var>object</var> <var>fname</var>))</code>, where the default for
<code><var>fname</var></code> is the mangling of <code><var>name</var></code>.

<h2>Changes from Kawa 1.6.60 to 1.6.62</h2>
<p>
The new function `invoke' allows you to call a Java method.
All of `invoke', `invoke-static' and `make' now select the
bets method.  They are also inlined at compile time in many
cases.  Specifically, if there is a method known to be
definitely applicable, based on compile-time types of the
argument expressions, the compiler will choose the most
specific such method.
<p>
The functions slot-ref, slot-set!, field, and static-field are
now inlined by the compiler when it can.
<p>
Added open-input-string, open-output-string, get-output-string from SRFI-6.
See http://srfi.schemers.org/srfi-6/srfi-6.html.
<p>
The manual has a new section "Mapping Scheme names to Java names",
and a new chapter "Types".  The chapters "Extensions", "Objects and
Classes", and "Low-level functions" have been extensivley re-organized.
<p>
The Kawa license has been simplified.  There used to be two licenses:
One for the packages gnu.*, and one for the packages kawa.*.  There
latter has been replaced by the former.  The "License" section of the
manual was also improved.

<h2>Changes from Kawa 1.6.59 to 1.6.60</h2>
<p>
There is a new package gnu.kawa.reflect.  Some classes
that used to be in kawa.lang or kawa.standard are now there.
<p>
The procedures slot-ref and slot-set! are now available.
They are equivalent to the existing `field', but reading
a field `x' will look for `getX' method if there is no public
`x' field; writing to a field will look for `setX'.
<p>
The procedure `make' makes it convenient to create new
objects.
<p>
There is now a teaser screen snapshot of "JEmacs"
at http://www.bothner.com/~per/papers/jemacs.png.
<p>
The html version of the manual now has a primitive index.
The manual has been slightly re-organized, with a new
"Classes and Objects" chapter.
<p>
The new functions invoke-static and class-methods allow you
to call an arbitary Java method.  They both take a class
specification and a method name.  The result of class-methods
is a generic procedure consisting of those methods whose names
match.  (Instance methods are also matched;  they are treated
the asme as class methods with an extra initial argument.)
The invoke-static function also takes extra arguments, and
actually calls the "best"-matching method.  An example:
<pre>
        (invoke-static &lt;java.lang.Thread&gt; 'sleep 100)
</pre>
<p>
Many fewer classes are now generated when compiling a Scheme file.
It used to be that each top-level procedure got compiled to its
own class;  that is no longer the case.  The change should
lead to faster startup and less resource use, but procedure
application will probably be noticably slower (though not so much
slower as when reflection is used).  The reason for the slowdown
is that we in the general case now do an extra method call, plus
a not-yet-optimized switch statement.  This change is part of the
new Kawa module system.  That will allow the compiler to
substitute direct methods calls in more cases, which I hope will
more than make up for the slowdown.
<p>
A Scheme procedure is now in general compiled to a Java method
whose name is a "mangling" of the Scheme procedure's name.  If the
procedure takes a variable number of parameters, then "$V" is added
to the name;  this indicates that the last argument is a Java
array containing the rest of the arguments.  Conversely, calling a
Java method whose name ends in "$V" passes any excess arguments in
the last argument, which must be an array type.
<p>
Many changes to the "Emacs-emulation" library in gnu.jemacs.buffer:
* Implemented commands to read and save files.
* We ask for file and buffer names using a dialog pop-up window.
* Split windows correctly, so that the windows that are not split
keep their sizes, the windows being split gets split as specified,
and the frame does not change size.  Now also handles horizonal splits.
* Fairly good support for  buffer-local keymaps and Emacs-style keymap
search order.  A new class BufferKeymap manages the active keymaps of
a buffer.  Multi-key key-sequences are handled.  Pending prefix keys
are remembered on a per-buffer basis (whereas Emacs does it globally).
<p>
There is now some low-level support for generic procedures.
<p>
The R5RS primitives let-syntax and letrec-syntax for defining local
syntax extensions (macros) should now work.  Also define-syntax works
as an internal definition.  All of these should now be properly
"hygienic".  (There is one known exception:  symbols listed among the
literals lists are matched as raw symbols, rather that checking that
the symbol has the same binding, if any, as at the defining site.)
The plan is to support general functions as hygienic rewriters, as in
the Chez Scheme "syntax-case" system;  as one part of that plan, the
syntax-case primitive is available, but so far without any of the
supporting machinary to support hygiene.
<p>
The read-line procedure was added.  This allows you to efficiently
read a line from an input port.  The interface is the same as scsh
and Guile.

<h2>Changes from Kawa 1.6.58 to 1.6.59</h2>
<p>
define-alias now works both top-level and inside a function.
<p>
Optimized eqv? so if one of the arguments is constant and
not Char or Numeric, inline it the same way eq? is.
(This helps case when the labels are symbols,
which help the "lattice" benchmark.) ???
<p>
The Emacs-related packages are now grouped under a new gnu.jemacs package.
<p>
Improved framework for catching errors.  This means improved error
messages when passing a parameter of the wrong type.  Many standard
procedures have been improved.
<p>
Simplified, documented, and tested (!) procedure for building Kawa
from source under Windows (95/98/NT).
<p>
New macros trace and untrace for tracing procedures.
After executing (trace PROCEDURE), debugging output will
be written (to the standard error port) every time PROCEDURE
is called, with the parameters and return value.  Use
(untrace PROCEDURE) to turn tracing off.
<p>
New utility functions (system-tmpdir) and (make-temporary-file [format]).
<p>
A new (unfinished) framework supports multiple languages.  The
command-line option --elisp selects Emacs Lisp, while --scheme
(the default) selects Scheme.  (The only difference so far is the
reader syntax;  that will change.)
<p>
The `format' function now  provides fairly complete functionality
for CommonLisp-style formatting.  (See the Comon Lisp hyperspec at
http://www.harlequin.com/education/books/HyperSpec/Body/sec_22-3.html.)
The floating point formatters (~F, ~E, ~G, ~$) now pass the formatst.scm
test (from Slib, but with some "fixes"; in the testsuite directory).  Also,
output ports now track column numbers, so <code>~T</code> and <code>~&amp;</code> also work correctly.
<p>
A new package gnu.emacs provides various building blocks
for building an Emacs-like text editor.  These classes
are only compiled when Kawa is configured with the
new --with-swing configuration option.  This is a large
initial step towards "JEmacs" - an Emacs re-implemented
to use Kawa, Java, and Swing, but with full support (using
gnu.elisp) for traditional Emacs Lisp.  For more imformation
see gnu/emacs/overview.html.
<p>
A new configuration option --with-swing can be used if Swing is available.
It is currently only used in gnu.emacs, but that may change.

<h2>Changes from Kawa 1.6.56 to 1.6.58</h2>
<p>
Kawa is now "properly tail-recursive" if you invoke it with the
--full-tail-calls flag.  (Exception: the eval procedure does not
perform proper tail calls, in violation of R5RS.  This will be
fixed in a future release.)  Code compiled when --full-tail-calls is
in effect is also properly tail-recursive.  Procedures compiled with
--full-tail-calls can call procedures compiled without it, and vice
versa (but of course without doing proper tail calls).  The default
is still --no-full-tail-calls, partly because of performance concerns,
partly because that provides better compatibility with Java
conventions and tools.
<p>
The keywords let (including named let), let*, and letrec support type
specifiers for the declared variables  For example:
<pre>
	(let ((lst :: &lt;list&gt; (foo x))) (reverse lst))
</pre>
<p>
Square brackets [ ... ] are allowed as a synonym of parentheses ( ... ).

<h2>Changes from Kawa 1.6.55 to 1.6.57</h2>
<p>
A new command-line flag --server PORT specifies that Kawa should run
as a telnet server on the specified PORT, creating a new read-eval-print
loop for each connection.  This allows you to connect using any
telnet client program to a remote "Kawa server".
<p>
A new front-end program, written in C, that provides editing of
input lines, using the GNU readline library.  This is a friendlier
interface than the plain "java kawa.repl".  However, because kawa.c
needs readline and suitable networking library support, it is not
built by default, but only when you configure Kawa with the
--enable-kawa-frontend flag.
<p>
The way Scheme names are mapped ("mangled") into Java identifiers
is now more natural.  E.g. "foo-bar?" now is mapped to "isFooBar".
<p>
New syntax (object (SUPERS ...) FIELD-AND-METHODS ...) for creating
a new object instance of an anonymous class.  Now fairly powerful.
<p>
New procedures field and static-field for more convenient field access.
<p>
Syntactic sugar:  <code>(lambda <var>args</var> &lt;<var>type</var>&gt; <var>body</var>)</code> -> <code>(lambda <var>args</var> (as &lt;<var>type</var>&gt; <var>body</var>))</code>.
This is especially useful for declaring methods in classes.
<p>
A new synchonized form allows you to synchronize on an arbitrary Java
object, and execute some forms while having an exclusive lock on the
object.  (The syntax matches that used by Skij.)

<h2>Changes from Kawa 1.6.53 to 1.6.55</h2>
<p>
New --debug-dump-zip option writes out a .zip file for compilation.
(Useful for debugging Kawa.)
<p>
You can now declare parameter types.
<p>
Lot of work on more efficient procedure representation and calling
convention:  Inlining, directly callable statics method, plus some
procedures no longer generate a separate Class.
<p>
Local functions that are only called from one locations, except for
tail-recursion, are now inlined.  This inlines do loops, and most
"named let" loops.
<p>
New representation of closures (closures with captured local variables).
We no longer use an array for the closure.  Instead we store the captured
variables in the Procedure itself.  This should be faster (since
we can use field accesses rather than array indexing, which requires
bounds checking), and avoids a separate environment object.
<p>
If the compiler sees a function call whose (non-lexically-bound) name
matches an existing (globally-defined) procedure, and that procedure
instance has a static method named either "apply" or the mangled
procedure name, them the compiler emits a direct call to that method.
This can make a very noticable speed difference, though it may
violate strict Scheme sementics, and some code may break.
<p>
Partial support for first-class "location" variables.

<h2>Changes from Kawa 1.6.53 to 1.6.54</h2>
<p>
Created new packages gnu.mapping and gnu.expr.  Many classes were
moved from kawa.lang to the new packages.
(This is part of the long-term process of splitting Kawa into more
manageable chunks, separating the Scheme-specific code from the
language-independent code, and moving classes under the gnu hierarchy.)
<p>
You can now write keywords with the colon first (e.g. :KEYWORD),
which has exactly the same effect and meaning as putting the colon
last (e.g. KEYWORD:).  The latter is preferred is being more consistent
with normal English use of punctuation, but the former is allowed
for compatibility with soem other Scheme implementations and Common Lisp.

<h2>Changes from Kawa 1.6.52 to 1.6.53</h2>
<p>
The new package gnu.text contains facilities for reading, formatting,
and manipulating text.  Some classes in kawa.lang where moved to there.
<p>
Added string-upcase!, string-downcase!, string-capitalize!, string-upcase,
string-downcase, and string-capitalize;  compatible with Slib.
<p>
Character constants can now use octal notation (as in Guile).
Writing a character uses octal format when that seems best.
<p>
A format function, similar to that in Common Lisp (and Slib) has been
added.
<p>
The default parameter of a #!optional or #!key parameter can now be #!null.

<h2>Changes since Kawa 1.6.51</h2>
<p>
The "record" feature has been changed to that a "record-type descriptor"
is now a gnu.bytecode.ClassType (a <code>&lt;record-type&gt;</code>), rather than a
java.lang.Class.  Thus make-record-type now returns a <code>&lt;record-typee&gt;</code>,
not a Class, and <code>record-type-descriptor</code> takes a <code>&lt;record-typee&gt;</code>,
not a Class.
<p>
More robust Eval interfaces.
<p>
New Lexer abstract class.  New ScmRead class (which extends Lexer)
now contains the Scheme reader (moved from Inport).
Now read errors are kept in queue, and can be recovered from.
<p>
Comparing an exact rational and an inexact real (double) is now done
as if by first converting the double to exact, to satisfy R5RS.

<h2>Changes since Kawa 1.6.1</h2>
<p>
The compile virtual method in Expression now takes a Target object,
representing the "destination".  The special ConditionalTarget is
used to evaluate the test of an 'if expression.  This allows us to
generate much better code for and, or, eq?, not and nested if
inside an if.
<p>
Added port-line, port-column, and set-port-line! to match Guile.
<p>
The Makefiles have been written so all out-of-date .java (or .scm).
files in a directory are compiled using a single invocation of
javac (or kawa).  Building Kawa should now be much faster.
(But note that this depends on unreleased recent autoamke changes.)
<p>
How the Kawa version number is compiled into Kawa was changed
to make it easier for people who want to build from source on
non-Unix-like systems.
<p>
A new gnu.ecmascript package contains an extremely incomplete implementation
of ECMSScript, the ECMA standardized version of JavaScript.  It includes
an ECMAScript lexer (basically complete), parser (the framework is
there but most of the language is missing), incomplete expression evaluation,
and a read-eval-print-loop (for testing only).

<h2>Changes in Kawa 1.6.1</h2>
<p>
Improved Kawa home page with extra links, pointer to Java-generated api docs,
and homepages for gnu.math and gnu.bytecode.
<p>
Implemented system, make-process, and some related procedures.
<p>
Added macros for primitive access to object fields, static fields, and
Java arrays.  Added constant-fold syntax, and used it for the other macros.
<p>
The --main flag compiles Scheme code to an application (containing a main
method), which can be be invoked directly by a Java interpreter.
<p>
Implemented --version (following GNU standards) as kawa.repl command-line flag.

<h2>Changes since Kawa 1.5.93</h2>
<p>
Adding make procedure to create new objects/records.
<p>
Extended (set! (f . args) value) to be equivalent to ((setter f) value . args).
Implemented setter, as well as (setter car) and (setter cdr).
<p>
Can now get and set a record field value using an application:
(rec 'fname) gets the value of the field named fname in record rec.
(set! (rec 'fname) value) sets the value of the field named fname in rec.
<p>
A partial re-write of the implementation of input ports and the Scheme
reader, to fix some problems, add some features, and improve performance.
<p>
Compiled .class files are now installed in $(datadir)/java,
rather than $(prefix)/java.  By default, that means they are
installed in /usr/local/shared/java, rather than /usr/local/java.
<p>
There is now internal infrastructure to support inlining of
procedures, and general procedure-specific optimized code
generation.
<p>
There is better testing that the right number of arguments are
passed to a procedure, and better error messages when you don't.
If the procedure is inlined, you get a compile-time error message.
<p>
The functions created by primitive-constructor, primitive-virtual-method,
primitive-static-method, and primitive-interface-method are now
first-class procedure values.  They use the Java reflection facily,
except when the compiler can directly inline them (in which case
it generates the same efficient bytecodes as before).
<p>
New functions instance? (tests type membership) and as (converts).
<p>
The kawa.html is now split into several files, one per chapter.
The table of contents is now kawa_toc.html.
<p>
The syntactic form try-catch provides low-level exception
handler support.  It is basically the same as Java's try/catch
form, but in Scheme syntax.  The new procedure primitive-throw
throws an exception object.
<p>
The higher-level catch and throw procedures implement
exception handling where the handler is specified with a "key"
(a symbol).  These functions were taken from Guile.
<p>
The error function has been generalized to take multiple arguments
(as in Guile).  It is now a wrapper around (throw 'misc-error ...).
<p>
There is a new "friendly" GUI access to the Kawa command-line.
If you invoke kawa.repl with the -w flag, a new interaction
window is created.  This is uses the AWT TextArea class.  You can
create multiple "consoles".  They can either share top-level
enevironments, or have separate environments.  This window
interface has some nice features, including editing.  Added a
scheme-window procedure, which is another way to create a window.

<h2>Changes since Kawa 1.5</h2>
<p>
The default prompt now shows continuations lines differently.
<p>
The copy-file function was added.
<p>
The variable port-char-encoding controls how external files
are converted to/from internal Unicode characters.  It also
controls whether CR and CR-LF are converted to LF.
<p>
The reader by default no longer down-cases letters in symbols.
A new variable symbol-read-case control how case is handled:
'P (the default) preserves case;  'U upper-cases letters;
'D or -" down-cases letters; and 'I inverts case.
<p>
The gnu.bytecode package now supports exception handlers.
The new syntactic form try-finally supports a cleanup hook that is run
after some other code finishes (normally or abnormally).
Try-finally is used to implement dynamic-wind and fluid-let.
<p>
The environment handling has been improved to support thread-specific
environments, a thread-safe fluid-let, and multiple top-levels.
(The latter still needs a bit of work.)
<p>
The gnu.bytecode package has been extensively changed.
There are new classes representing the various standard Attributes,
and data associated with an attribute is now stored there.
<p>
Added new procedures environment-bound? and scheme-implementation-version.
<p>
Scheme symbols are represented as java.lang.String objects.
Interned symbols are interned Strings;  uninterned symbols are
uninterned Strings.  Note that Java strings literals are
automatically interned in JDK 1.1.  This change makes symbols
slightly more efficient, and moves Kawa closer to Java.
<p>
Ports now use the JDK 1.1 character-based Reader and Writer classes,
rather than the byte-oriented InputStream and OutputStream classes.
This supports different reading and writing different character
encodings [in theory - there is no support yet for other than Ascii
or binary files].
<p>
An interactive input port now has a prompt function associated with it.
It is settable with set-input-port-prompter!.  The prompt function
takes one argument (the input port), and returns a prompt string.
There are also user functions for inquiring about the current line
and column number of an input port.
<p>
The R4RS procedures transcript-on and transcript-off are implemented.
<p>
Standard types can be referred to using syntax similar to RScheme.
For example Scheme strings now have the type <code>&lt;string&gt;</code> which is
preferred to "<code>kawa.lang.FString</code>" (which in addition to being longer,
is also more suspectible to changes in internal implementation).
Though these types are first-class values, this is so far mainly
useful for invoking primitive methods.

<h2>Changes from Kawa 1.4 to 1.5</h2>
<p>
Execute a ~/.kawarc.scm file on startup, if it exists.
<p>
Add a number of functions for testing, renaming, and deleting files.
These are meant to be compatible with scsh, Guile, and MIT Scheme:
file-exists?, file-directory?, file-readable?, file-writable?, delete-file,
rename-file, create-diretory, and the variable home-directory.
<p>
Fixed some small bugs, mainly in gnu.math and in load.
<p>
Generalize apply to accept an arbitrary Sequence, or a primitive Java array.

<h2>Changes from Kawa 1.2 to 1.4</h2>
<p>
The codegen package has been renamed gnu.bytecode.
The kawa.math package has been moved to gnu.math.
Both packages have new license:  No restrictions if you use an
unmodified release, but GNU General Public License.  Let me know
if that causes problems.  The rest of Kawa still has the old license.
<p>
Implement defmacro and gentemp.
<p>
Implement make-record-type and related functions to create and use
new record types.  A record type is implemented as a java.lang.Class
object, and this feature depends on the new reflection features of JDK 1.1.
<p>
Implement keywords, and extend lambda parameter lists to support
#!optional #!rest and #!keyword parameters (following DSSSL).
<p>
Added more primitives to call arbitrary interface and constructor methods.

<h2>Changes from Kawa 1.0 to 1.2</h2>
<p>
Added primitives to make it easy to call arbitrary Java methods
from Scheme.
<p>
Exact rational arithetic is now fully implemented.
All integer functions now believed to correctly handle bignums.
Logical operations on exact integers have been implemented.
These include all the logical functions from Guile.
<p>
Complex numbers are implemented (except {,a}{sin,cos,tan}).
Quantities (with units) are implemented (as in DSSSL).
<p>
Eval is available, as specified for R5RS.
Also implemented are scheme-report-environment, null-environment, and
interaction-environment.
<p>
Internal define is implemented.
<p>
Rough support for multiple threads is implemented.
<p>
Moved kawa class to kawa/repl.  Merged in kawac (compiler)
functionality.  A 'kawa' shell-script is now created.
This is now the preferred interface to both the interactive
evaluator and the compiler (on Unix-like systems).
<p>
Now builds "without a snag" using Cafe 1.51 under Win95.
(Symantec JIT (ver 2.00b19) requires disabling JIT -
<code>JAVA_COMPCMD=disable</code>.)
Compiles under JDK 1.1 beta (with some warnings).
<p>
A testsuite (and testing framework) was added.
<p>
Documentation moved to doc directory.
There is now an internals overview, in doc/kawa-tour.ps.

<h2>Changes since 0.4</h2>
<p>
The numeric classes have been re-written.  There is partial support
for bignums (infinite-precision integers), but divide (for example)
has not been implemented yet.  The representation of bignums uses
2's complement, where the "big digits" are laid out so as to be
compatible with the mpn functions of the GNU Multi-Precision library
(gmp).  (The intent is that a future version of Kawa will support
an option to use gmp native functions for speed.)
<p>
The kawa application takes a number of useful command-line switches.
<p>
Basically all of R4RS has been implemented.  All the essential
forms and functions are implemented.  Almost all of the optional
forms are implemented.  The exceptions are transcript-on,
transcript-off, and the functions for complex numbers,
and fractions (exact non-integer rationals).
<p>
Loading a source file with load now wraps the entire file in
a lambda (named "atFileLevel").  This is for better error
reporting, and consistency with compile-file.

<h2>Changes since 0.3</h2>
<p>
The hygienic macros described in the appendix to R4RS are now
impemented (but only the define-syntax form).  They are
used to implement the standard "do" form.
<p>
The R5RS multiple value functions <code>values</code> and <code>call-with-values</code> are implemented.
<p>
Macros (and primitive syntax) can now be autoloaded as well as procedures.
<p>
New kawac application compiles to one or more .class files.
<p>
Compile time errors include line numbers.
Uncaught exceptions cause a stack trace that includes .scm line numbers.
This makes it more practical to debug Kawa with a Java debugger.
<p>
Quasiquotation is implemented.
<p>
Various minor bug fixes and optimizations.

<h2>Changes since 0.2</h2>
<p>
The biggest single change is that Scheme procedures are now compiled
to Java bytecodes.  This is mainly for efficiency, but it also allows
us to do tail-recursion-elimination in some cases.
<p>
The "codegen" library is included.  This is a toolkit that handles
most of the details needed to generate Java bytecode (.class) files.
<p>
The internal structure of Kawa has been extensively re-written,
especially how syntax transforms, eval, and apply are done,
largely due to the needs for compilation.
<p>
Almost all the R4RS procedures are now implemented, except that
there are still large gaps in Section 6.5 "Numbers".
    <hr>
    <address><a href="mailto:per@bothner.com">Per Bothner</a></address>
<!-- Created: Fri Apr  8 2005 -->
  </body>
</html>
