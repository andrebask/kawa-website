<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Kawa: Object, Classes and Modules</title>
<link rel="stylesheet" title="Kawa (navbar: fixed, left)" href="style/kawa-l.css" media="screen, print, projection, tv">
<link rel="alternate stylesheet" title="Kawa (navbar: fixed, right)" href="style/kawa-r.css" media="screen, print, projection, tv">
<link rel="alternate stylesheet" title="Single column, top navigation" href="style/kawa-1col.css" type="text/css" media="handheld, screen, print, projection, tv">
<script language="JavaScript" type="text/javascript" src="style/utils.js"></script><meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="toc.html" title="Kawa: The Kawa Scheme language">
<link rel="up" href="Documentation.html" title="Kawa: Documentation">
<link rel="prev" href="Types.html" title="Kawa: Types">
<link rel="next" href="XML-tools.html" title="Kawa: Working with XML and HTML">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF" onload="javascript:onLoadHandler();" onunload="javascript:onUnloadHandler();">
<div class="navcol">
<div class="logo"><a href="index.html"><img src="style/kawa-logo.png"></a></div>
<div class="navbar">
<ul>
<li><a href="toc.html">Table of Contents</a></li>
<li><a href="tutorial/index.html">Tutorial</a></li>
<li><a href="news.html">News: Recent changes</a></li>
</ul>
<div class="toc"><ul>
<li><a href="index.html">The Kawa Scheme language</a></li>
<li><a href="Installation.html">Getting and installing Kawa</a></li>
<li><a href="Features.html">Features</a></li>
<li>
<a href="Documentation.html">Documentation</a><ul>
<li><a href="Running.html">Usage Reference</a></li>
<li><a href="Syntax.html">Syntax</a></li>
<li><a href="Program-structure.html">Program structure</a></li>
<li><a href="Multiple-values.html">Multiple values</a></li>
<li><a href="Symbols-and-namespaces.html">Symbols and namespaces</a></li>
<li><a href="Procedures.html">Procedures</a></li>
<li><a href="Numbers.html">Numbers</a></li>
<li><a href="Characters-and-text.html">Characters and text</a></li>
<li><a href="Data-structures.html">Data structures</a></li>
<li><a href="Eval-and-Environments.html">Eval and Environments</a></li>
<li><a href="Debugging.html">Debugging</a></li>
<li><a href="Input-Output.html">Input, output, files</a></li>
<li><a href="Types.html">Types</a></li>
<li>
<b class="toc"><a href="Objects-Classes-and-Modules.html">Object, Classes and Modules</a></b><ul>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Defining-new-classes">Defining new classes</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Anonymous-classes">Anonymous classes</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Enumerations">Enumeration types</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Annotations">Annotations of declarations</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Module-classes">Modules and how they are compiled to classes</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Record-types">Record types</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Dynamic-records">Creating New Record Types On-the-fly</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Method-operations">Calling Java methods from Scheme</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Allocating-objects">Allocating objects</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Field-operations">Accessing object fields</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Mangling">Mapping Scheme names to Java names</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Scheme-types-in-Java">Scheme types in Java</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Array-operations">Using Java Arrays</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Loading-Java-functions-into-Scheme">Loading Java functions into Scheme</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Evaluating-Scheme-expressions-from-Java">Evaluating Scheme expressions from Java</a></b></li>
</ul>
</li>
<li><a href="XML-tools.html">Working with XML and HTML</a></li>
<li><a href="Miscellaneous.html">Miscellaneous topics</a></li>
</ul>
</li>
<li><a href="Development.html">Development</a></li>
<li><a href="Community.html">The Kawa Community</a></li>
<li><a href="About.html">About</a></li>
<li><a href="Overall-Index.html">Index</a></li>
</ul></div>
</div>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="Objects-Classes-and-Modules"></a>Object, Classes and Modules</h2></div></div></div>
<p>Kawa provides various ways to define, create, and access Java objects.
Here are the currently supported features.
</p>
<p>The Kawa module system is based on the features of the Java class system.
</p>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48226784"></a><code class="function">this</code></p>
<div class="blockquote"><blockquote class="blockquote"><p>Returns the "this object" - the current instance of the current class.
The current implementation is incomplete, not robust, and not
well defined.  However, it will have to do for now.
Note:  "<code class="literal">this</code>" is a macro, not a variable, so you have to write
it using parentheses: ‘<code class="literal">(this)</code>’.  A planned extension will
allow an optional class specifier (needed for nested clases).
</p></blockquote></div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="Defining-new-classes"></a>Defining new classes</h3></div></div></div>
<p>Kawa provides various mechanisms for defining new classes.
The <code class="literal">define-class</code> and <code class="literal">define-simple-class</code> forms
will usually be the preferred mechanisms.  They have basically
the same syntax, but have a couple of differences.
<code class="literal">define-class</code> allows multiple inheritance as well as true nested
(first-class) class objects.  However, the implementation
is more complex: code using it is slightly slower, and the mapping to
Java classes is a little less obvious.   (Each Scheme class is implemented
as a pair of an interface and an implementation class.)
A class defined by <code class="literal">define-simple-class</code> is slightly more
efficient, and it is easier to access it from Java code.
</p>
<p>The syntax of <code class="literal">define-class</code> are mostly compatible with that
in the Guile and Stk dialects of Scheme.
</p>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48238368"></a><code class="function">define-class</code><em class="replaceable"><code> <a class="link" href="Objects-Classes-and-Modules.html#meta-class-name"><em class="replaceable"><code>class-name</code></em></a></code></em><em class="replaceable"><code> <code class="literal"><span class="bold"><strong>(</strong></span></code></code></em><em class="replaceable"><code>supers</code></em><em class="replaceable"><code> ...</code></em><em class="replaceable"><code><code class="literal"><span class="bold"><strong>)</strong></span></code></code></em> (<em class="replaceable"><code><a class="link" href="Objects-Classes-and-Modules.html#meta-annotation"><em class="replaceable"><code>annotation</code></em></a></code></em><em class="replaceable"><code>|</code></em><em class="replaceable"><code><a class="link" href="Objects-Classes-and-Modules.html#meta-option-pair"><em class="replaceable"><code>option-pair</code></em></a></code></em>)<em class="replaceable"><code>*</code></em><em class="replaceable"><code> <a class="link" href="Objects-Classes-and-Modules.html#meta-field-or-method-decl"><em class="replaceable"><code>field-or-method-decl</code></em></a></code></em><em class="replaceable"><code> ...</code></em></p>
<p class="synopsis"><a class="indexterm" name="idp48248976"></a><code class="function">define-simple-class</code><em class="replaceable"><code> <a class="link" href="Objects-Classes-and-Modules.html#meta-class-name"><em class="replaceable"><code>class-name</code></em></a></code></em><em class="replaceable"><code> <code class="literal"><span class="bold"><strong>(</strong></span></code></code></em><em class="replaceable"><code>supers</code></em><em class="replaceable"><code> ...</code></em><em class="replaceable"><code><code class="literal"><span class="bold"><strong>)</strong></span></code></code></em> (<em class="replaceable"><code><a class="link" href="Objects-Classes-and-Modules.html#meta-annotation"><em class="replaceable"><code>annotation</code></em></a></code></em><em class="replaceable"><code>|</code></em><em class="replaceable"><code><a class="link" href="Objects-Classes-and-Modules.html#meta-option-pair"><em class="replaceable"><code>option-pair</code></em></a></code></em>)<em class="replaceable"><code>*</code></em><em class="replaceable"><code> <a class="link" href="Objects-Classes-and-Modules.html#meta-field-or-method-decl"><em class="replaceable"><code>field-or-method-decl</code></em></a></code></em><em class="replaceable"><code> ...</code></em></p>
<div class="blockquote"><blockquote class="blockquote"><p>Defines a new class named <em class="replaceable"><code>class-name</code></em>.  If <code class="literal">define-simple-class</code> is
used, creates a normal Java class named <em class="replaceable"><code>class-name</code></em> in the current package.
(If <em class="replaceable"><code>class-name</code></em> has the form <code class="literal">&lt;xyz&gt;</code> the Java implementation
type is named <code class="literal">xyz</code>.)  For <code class="literal">define-class</code> the implementation is
unspecified.  In most cases, the compiler creates a class pair,
consisting of a Java interface and a Java implementation class.
</p></blockquote></div>
</div>
<div class="literallayout"><p><a class="indexterm" name="idp48264080"></a><a name="meta-class-name"></a><em class="replaceable"><code>class-name</code></em> <code class="literal">::=</code> <a class="link" href="Syntax.html#meta-identifier"><em class="replaceable"><code>identifier</code></em></a><br>
<a class="indexterm" name="idp48267696"></a><a name="meta-option-pair"></a><em class="replaceable"><code>option-pair</code></em> <code class="literal">::=</code> <em class="replaceable"><code>option-keyword</code></em> <em class="replaceable"><code>option-value</code></em><br>
<a class="indexterm" name="idp48271152"></a><a name="meta-field-or-method-decl"></a><em class="replaceable"><code>field-or-method-decl</code></em> <code class="literal">::=</code> <a class="link" href="Objects-Classes-and-Modules.html#meta-field-decl"><em class="replaceable"><code>field-decl</code></em></a> | <a class="link" href="Objects-Classes-and-Modules.html#meta-method-decl"><em class="replaceable"><code>method-decl</code></em></a><br>
</p></div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="General-class-properties"></a>General class properties</h4></div></div></div>
<p>The class inherits from the classes and interfaces listed in <em class="replaceable"><code>supers</code></em>.
This is a list of names of classes that are in scope (perhaps imported
using <code class="literal">require</code>), or names for existing classes or interfaces
optionally surrounded by <code class="literal">&lt;&gt;</code>, such as <code class="literal">&lt;gnu.lists.Sequence&gt;</code>.
If <code class="literal">define-simple-class</code> is used, at most one of these may be
the name of a normal Java class or classes defined using
<code class="literal">define-simple-class</code>; the rest must be interfaces or classes
defined using <code class="literal">define-class</code>.
If <code class="literal">define-class</code> is used, <span class="emphasis"><em>all</em></span> of the classes listed
in <em class="replaceable"><code>supers</code></em> should be interfaces or classes defined using
<code class="literal">define-class</code>.
</p>
<div class="variablelist"><dl class="variablelist">
<dt class="term">
<code class="literal"><span class="bold"><strong>interface:</strong></span></code> <em class="replaceable"><code>make-interface</code></em>
</dt>
<dd><p>Specifies whether Kawa generates a Java class, interface, or both.
If <em class="replaceable"><code>make-interface</code></em> is <code class="literal">#t</code>, then a Java interface is generated.
In that case all the supertypes must be interfaces, and
all the declared methods must be abstract.
If <em class="replaceable"><code>make-interface</code></em> is <code class="literal">#f</code>, then a Java class is generated.
If <code class="literal">interface:</code>  is unspecified, the default is <code class="literal">#f</code>
for <code class="literal">define-simple-class</code>.  For <code class="literal">define-class</code> the default
is to generate an interface, and in addition (if needed) a helper
class that implements the interface.  (In that case any non-abstract methods
are compiled to static methods.  The methods that implement the interface
are just wrapper methods that call the real static methods.  This
allows Kawa to implement true multiple inheritance.)
</p></dd>
<dt class="term">
<code class="literal"><span class="bold"><strong>access:</strong></span></code> <em class="replaceable"><code>kind</code></em>
</dt>
<dd>
<p>Specifies the Java access permission on the class.
Can be one of <code class="literal">'public</code> (which is the default in Kawa),
<code class="literal">'package</code> (which the default "unnamed" permission in Java code),
<code class="literal">'protected</code>, <code class="literal">'private</code>,
<code class="literal">'volatile</code>, or <code class="literal">'transient</code>.
Can also be used to specify <code class="literal">final</code>, <code class="literal">abstract</code>, or <code class="literal">enum</code>, as in Java.
(You don't need to explicitly specify the class is <code class="literal">abstract</code>
if any <em class="replaceable"><code>method-body</code></em> is <code class="literal">#!abstract</code>,
or you specify <code class="literal">interface: #t</code>.)
The <em class="replaceable"><code>kind</code></em> can also be a list, as for example:
</p>
<pre class="screen">access: '(protected volatile)
</pre>
</dd>
<dt class="term">
<code class="literal"><span class="bold"><strong>class-name:</strong></span></code> <code class="literal">"</code><em class="replaceable"><code>cname</code></em><code class="literal">"</code>
</dt>
<dd><p>Specifies the Java name of the created class.
The <em class="replaceable"><code>name</code></em> specified after <code class="literal">define-class</code>
or <code class="literal">define-simple-class</code> is the <span class="emphasis"><em>Scheme name</em></span>,
i.e. the name of a Scheme variable that is bound to the class.
The Java name is by default derived from the Scheme name,
but you can override the default with a <code class="literal">class-name:</code> specifier.
If the <em class="replaceable"><code>cname</code></em> has no periods, then it is a name in
the package of the main (module) class.
If the <em class="replaceable"><code>cname</code></em> starts with a period,
then you get a class nested within the module class.
In this case the actual class name is <em class="replaceable"><code>moduleClass</code></em><code class="literal">$</code><em class="replaceable"><code>rname</code></em>,
where <em class="replaceable"><code>rname</code></em> is <em class="replaceable"><code>cname</code></em> without the initial period.
To force a class in the top-level (unnamed) package (something
not recommended) write a period at the end of the <em class="replaceable"><code>cname</code></em>.
</p></dd>
</dl></div>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Declaring-fields"></a>Declaring fields</h4></div></div></div>
<div class="literallayout"><p><a class="indexterm" name="idp48318048"></a><a name="meta-field-decl"></a><em class="replaceable"><code>field-decl</code></em> <code class="literal">::=</code> <code class="literal"><span class="bold"><strong>(</strong></span></code><a class="link" href="Objects-Classes-and-Modules.html#meta-field-name"><em class="replaceable"><code>field-name</code></em></a> (<a class="link" href="Objects-Classes-and-Modules.html#meta-annotation"><em class="replaceable"><code>annotation</code></em></a> | <a class="link" href="Types.html#meta-opt-type-specifier"><em class="replaceable"><code>opt-type-specifier</code></em></a> | <a class="link" href="Objects-Classes-and-Modules.html#meta-field-option"><em class="replaceable"><code>field-option</code></em></a>)*<code class="literal"><span class="bold"><strong>)</strong></span></code><br>
<a class="indexterm" name="idp48326672"></a><a name="meta-field-name"></a><em class="replaceable"><code>field-name</code></em> <code class="literal">::=</code> <a class="link" href="Syntax.html#meta-identifier"><em class="replaceable"><code>identifier</code></em></a><br>
<a class="indexterm" name="idp48330288"></a><a name="meta-field-option"></a><em class="replaceable"><code>field-option</code></em> <code class="literal">::=</code> <a class="link" href="Symbols-and-namespaces.html#meta-keyword"><em class="replaceable"><code>keyword</code></em></a> <a class="link" href="Syntax.html#meta-expression"><em class="replaceable"><code>expression</code></em></a><br>
</p></div>
<p>As a matter of style the following order is suggested, though this not enforced:
</p>
<div class="literallayout"><p><code class="literal"><span class="bold"><strong>(</strong></span></code><a class="link" href="Objects-Classes-and-Modules.html#meta-field-name"><em class="replaceable"><code>field-name</code></em></a> <a class="link" href="Objects-Classes-and-Modules.html#meta-annotation"><em class="replaceable"><code>annotation</code></em></a>* <a class="link" href="Types.html#meta-opt-type-specifier"><em class="replaceable"><code>opt-type-specifier</code></em></a> <a class="link" href="Objects-Classes-and-Modules.html#meta-field-option"><em class="replaceable"><code>field-option</code></em></a>*<code class="literal"><span class="bold"><strong>)</strong></span></code><br>
</p></div>
<p>Each <em class="replaceable"><code>field-decl</code></em> declares a instance "slot" (field)
with the given <em class="replaceable"><code>field-name</code></em>.
By default it is publicly visible, but you can specify
a different visiblity with the <code class="literal">access:</code> specifier.
The following <em class="replaceable"><code>field-option</code></em> <em class="replaceable"><code>keyword</code></em>s are implemented:
</p>
<div class="variablelist"><dl class="variablelist">
<dt class="term">
<code class="literal"><span class="bold"><strong>type:</strong></span></code> <a class="link" href="Types.html#meta-type"><em class="replaceable"><code>type</code></em></a>
</dt>
<dd><p>Specifies that <em class="replaceable"><code>type</code></em> is the type of (the values of) the field.
Equivalent to ‘<code class="literal">:: <em class="replaceable"><code>type</code></em></code>’.
</p></dd>
<dt class="term">
<code class="literal"><span class="bold"><strong>allocation:</strong></span></code> <em class="replaceable"><code>kind</code></em>
</dt>
<dd>
<p>If <em class="replaceable"><code>kind</code></em> is <code class="literal">'class</code> or <code class="literal">'static</code> a single slot is shared
between all instances of the class (and its sub-classes).
Not yet implemented for <code class="literal">define-class</code>,
only for <code class="literal">define-simple-class</code>.
In Java terms this is a <code class="literal">static</code> field.
</p>
<p>If <em class="replaceable"><code>kind</code></em> is <code class="literal">'instance</code> then
each instance has a separate value "slot", and they
are not shared. In Java terms, this is a non-<code class="literal">static</code> field.
This is the default.
</p>
</dd>
<dt class="term">
<code class="literal"><span class="bold"><strong>access:</strong></span></code> <em class="replaceable"><code>kind</code></em>
</dt>
<dd><p>Specifies the Java access permission on the field.
Can be one of <code class="literal">'private</code>, <code class="literal">'protected</code>,
<code class="literal">'public</code> (which is the default in Kawa),
or <code class="literal">'package</code> (which the default "unnamed" permission
in Java code).
Can also be used to specify <code class="literal">volatile</code>, <code class="literal">transient</code>,
<code class="literal">enum</code>, or <code class="literal">final</code>, as in Java.
</p></dd>
<dt class="term">
<code class="literal"><span class="bold"><strong>init:</strong></span></code> <em class="replaceable"><code>expr</code></em>
</dt>
<dd><p>An expression used to initialize the slot.
The expression is evaluated in a scope that includes the field and
method names of the current class.
</p></dd>
<dt class="term">
<code class="literal"><span class="bold"><strong>init-form:</strong></span></code> <em class="replaceable"><code>expr</code></em>
</dt>
<dd><p>An expression used to initialize the slot.
The lexical environment of the <em class="replaceable"><code>expr</code></em> is that of the <code class="literal">define-class</code>;
it does <span class="emphasis"><em>not</em></span> include the field and method names of the current class.
or <code class="literal">define-simple-class</code>.
</p></dd>
<dt class="term">
<code class="literal"><span class="bold"><strong>init-value:</strong></span></code> <em class="replaceable"><code>value</code></em>
</dt>
<dd><p>A value expression used to initialize the slot.
For now this is synonymous with <em class="replaceable"><code>init-form:</code></em>, but that may change
(depending on what other implementation do), so to be safe only use
<code class="literal">init-value:</code> with a literal.
</p></dd>
<dt class="term">
<code class="literal"><span class="bold"><strong>init-keyword:</strong></span></code> <code class="literal"><em class="replaceable"><code>name</code></em>:</code>
</dt>
<dd><p>A keyword that that can be used to initialize instance in <code class="literal">make</code> calls.
For now, this is ignored, and <em class="replaceable"><code>name</code></em> should be the same as the
field's <em class="replaceable"><code>field-name</code></em>.
</p></dd>
</dl></div>
<p>The <em class="replaceable"><code>field-name</code></em> can be left out.  That indicates a "dummy slot",
which is useful for initialization not tied to a specific field.
In Java terms this is an instance or static initializer, i.e., a
block of code executed when a new instance is created or the class is loaded.
</p>
<p>In this example, <code class="literal">x</code> is the only actual field.  It is first
initialized to 10, but if <code class="literal">(some-condition)</code> is true
then its value is doubled.
</p>
<pre class="screen">(define-simple-class &lt;my-class&gt; ()
  (allocation: 'class
   init: (perform-actions-when-the-class-is-initizalized))
  (x init: 10)
  (init: (if (some-condition) (set! x (* x 2)))))
</pre>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Declaring-methods"></a>Declaring methods</h4></div></div></div>
<div class="literallayout"><p><a class="indexterm" name="idp48388112"></a><a name="meta-method-decl"></a><em class="replaceable"><code>method-decl</code></em> <code class="literal">::=</code> <code class="literal"><span class="bold"><strong>((</strong></span></code><a class="link" href="Objects-Classes-and-Modules.html#meta-method-name"><em class="replaceable"><code>method-name</code></em></a> <a class="link" href="Procedures.html#meta-formal-arguments"><em class="replaceable"><code>formal-arguments</code></em></a><code class="literal"><span class="bold"><strong>)</strong></span></code><br>
    (<a class="link" href="Objects-Classes-and-Modules.html#meta-annotation"><em class="replaceable"><code>annotation</code></em></a> | <a class="link" href="Procedures.html#meta-opt-return-type"><em class="replaceable"><code>opt-return-type</code></em></a> | <a class="link" href="Objects-Classes-and-Modules.html#meta-option-pair"><em class="replaceable"><code>option-pair</code></em></a>)* [<a class="link" href="Objects-Classes-and-Modules.html#meta-deprecated-return-specifier"><em class="replaceable"><code>deprecated-return-specifier</code></em></a>] <a class="link" href="Objects-Classes-and-Modules.html#meta-method-body"><em class="replaceable"><code>method-body</code></em></a><code class="literal"><span class="bold"><strong>)</strong></span></code><br>
<a class="indexterm" name="idp48400480"></a><a name="meta-method-name"></a><em class="replaceable"><code>method-name</code></em> <code class="literal">::=</code> <a class="link" href="Syntax.html#meta-identifier"><em class="replaceable"><code>identifier</code></em></a><br>
<a class="indexterm" name="idp48404096"></a><a name="meta-method-body"></a><em class="replaceable"><code>method-body</code></em> <code class="literal">::=</code> <a class="link" href="Syntax.html#meta-body"><em class="replaceable"><code>body</code></em></a> | <code class="literal"><span class="bold"><strong>#!abstract</strong></span></code> | <code class="literal"><span class="bold"><strong>#!native</strong></span></code><br>
<a class="indexterm" name="idp48409888"></a><a name="meta-deprecated-return-specifier"></a><em class="replaceable"><code>deprecated-return-specifier</code></em> <code class="literal">::=</code> <a class="link" href="Syntax.html#meta-identifier"><em class="replaceable"><code>identifier</code></em></a><br>
</p></div>
<p>Each <em class="replaceable"><code>method-decl</code></em> declares a method,
which is by default public and non-static, and whose name is <em class="replaceable"><code>method-name</code></em>.
(If <em class="replaceable"><code>method-name</code></em> is not a valid
Java method name, it is mapped to something reasonable.
For example <code class="literal">foo-bar?</code> is mapped to <code class="literal">isFooBar</code>.)
The types of the method arguments can be specified in the
<em class="replaceable"><code>formal-arguments</code></em>.  The return type can be specified by
a <em class="replaceable"><code>opt-return-type</code></em>, <em class="replaceable"><code>deprecated-return-specifier</code></em>,
or is otherwise the type of the <em class="replaceable"><code>body</code></em>.
Currently, the <em class="replaceable"><code>formal-arguments</code></em> cannot contain optional, rest,
or keyword parameters.  (The plan is to allow optional parameters,
implemented using multiple overloaded methods.)
</p>
<p>A <em class="replaceable"><code>method-decl</code></em> in a <code class="literal">define-simple-class</code>
can have the following <em class="replaceable"><code>option-keyword</code></em>s:
</p>
<div class="variablelist"><dl class="variablelist">
<dt class="term">
<code class="literal"><span class="bold"><strong>access:</strong></span></code> <em class="replaceable"><code>kind</code></em>
</dt>
<dd><p>Specifies the Java access permission on the method.
Can be one of <code class="literal">'private</code>, <code class="literal">'protected</code>,
<code class="literal">'public</code>, or <code class="literal">'package</code>.
</p></dd>
<dt class="term">
<code class="literal"><span class="bold"><strong>allocation:</strong></span></code> <em class="replaceable"><code>kind</code></em>
</dt>
<dd><p>If <em class="replaceable"><code>kind</code></em> is <code class="literal">'class</code> or <code class="literal">'static</code> creates a static method.
</p></dd>
<dt class="term">
<code class="literal"><span class="bold"><strong>throws:</strong></span></code> ( <em class="replaceable"><code>exception-class-name</code></em> ... )</dt>
<dd>
<p>Specifies a list of checked exception that the method may throw.
Equivalent to a <code class="literal">throws</code> specification in Java code.
For example:
</p>
<pre class="screen">(define-simple-class T
  (prefix)
  ((lookup name) throws: (java.io.FileNotFoundException)
   (make java.io.FileReader (string-append prefix name))))
</pre>
</dd>
</dl></div>
<p>The scope of the <em class="replaceable"><code>body</code></em> of a method includes the <em class="replaceable"><code>field-decl</code></em>s
and <em class="replaceable"><code>field-decl</code></em>s of the body, including those inherited from
superclasses and implemented interfaces.
</p>
<p>If the <em class="replaceable"><code>method-body</code></em> is the special form <code class="literal">#!abstract</code>,
then the method is abstract.  This means the method must
be overridden in a subclass, and you're not allowed to
create an instance of the enclosing class.
</p>
<pre class="screen">(define-simple-class Searchable () interface: #t
  ((search value) :: boolean #!abstract))
</pre>
<p>If the <em class="replaceable"><code>method-body</code></em> is the special form <code class="literal">#!native</code>,
then the method is native, implemented using <a class="ulink" href="http://en.wikipedia.org/wiki/Java_Native_Interface" target="_top">JNI</a>.
</p>
<p>The special <em class="replaceable"><code>method-name</code></em> ‘<code class="literal">*init*</code>’ can be used to name
a non-default constructor (only if <em class="replaceable"><code>make-interface</code></em> discussed above
is <code class="literal">#f</code>).
It can be used to initialize a freshly-allocated instance
using passed-in parameters.
You can call a superclass or a sibling constructor using
the <code class="literal">invoke-special</code> special function.
(This is general but admittedly a bit verbose; a more compact
form may be added in the future.)
See the example below.
</p>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Example"></a>Example</h4></div></div></div>
<p>In the following example we define a simple class <code class="literal">2d-vector</code>
and a class <code class="literal">3d-vector</code> that extends it.  (This is for illustration
only - defining 3-dimensional points as an extension
of 2-dimensional points does not really make sense.)
</p>
<pre class="screen">(define-simple-class 2d-vector ()
  (x ::double init-keyword: x:)
  ;; Alternative type-specification syntax.
  (y type: double init-keyword: y:)
  (zero-2d :: 2d-vector allocation: 'static
   init-value: (2d-vector 0))
  ;; An object initializer (constructor) method.
  ((*init* (x0 ::double) (y0 ::double))
   (set! x x0)
   (set! y y0))
  ((*init* (xy0 ::double))
   ;; Call above 2-argument constructor.
   (invoke-special 2d-vector (this) '*init* xy0 xy0))
  ;; Need a default constructor as well.
  ((*init*) #!void)
  ((add (other ::2d-vector)) ::2d-vector
   ;; Kawa compiles this using primitive Java types!
   (2d-vector
     x: (+ x other:x)
     y: (+ y other:y)))
  ((scale (factor ::double)) ::2d-vector
   (2d-vector x: (* factor x) y: (* factor y))))

(define-simple-class 3d-vector (2d-vector)
  (z type: double init-value: 0.0 init-keyword: z:)
  ;; A constructor which calls the superclass constructor.
  ((*init* (x0 ::double) (y0 ::double) (z0 ::double))
   (invoke-special 2d-vector (this) '*init* x0 y0)
   (set! z z0))
  ;; Need a default constructor.
  ((*init*) #!void)
  ((scale (factor ::double)) ::2d-vector
   ;; Note we cannot override the return type to 3d-vector
   ;; because Kawa doesn't yet support covariant return types.
   (3d-vector
     x: (* factor x)
     y: (* factor (this):y) ;; Alternative syntax.
     z: (* factor z))))
</pre>
<p>Note we define both explicit non-default constructor methods,
and we associate fields with keywords, so they can be named
when allocating an object.  Using keywords requires a default constructor,
and since having non-default constructors suppresses
the implicit default constructor we have to explicitly define it.
Using both styles of constructors is rather redundant, though.
</p>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Synchronized-methods"></a>Synchronized methods</h4></div></div></div>
<a class="indexterm" name="idp48453200"></a><p>Kawa doesn't directly support marking a method as <code class="literal">synchronized</code>,
but you can get the same effect using a <code class="literal">synchronized</code> expression:
</p>
<pre class="screen">(define-simple-class &lt;Bar&gt; ()
  ;; non-static method
  ((foo) :: void
   (synchronized (this)
		 (synchronized-block)))
  ;; static method
  ((baz) allocation: 'static :: void
   (synchronized &lt;Bar&gt;
		 (synchronized-block))))
</pre>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="Anonymous-classes"></a>Anonymous classes</h3></div></div></div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48459856"></a><code class="function">object</code><em class="replaceable"><code> <code class="literal"><span class="bold"><strong>(</strong></span></code></code></em><em class="replaceable"><code>supers</code></em><em class="replaceable"><code> ...</code></em><em class="replaceable"><code><code class="literal"><span class="bold"><strong>)</strong></span></code></code></em><em class="replaceable"><code> field-or-method-decl</code></em><em class="replaceable"><code> ...</code></em></p>
<div class="blockquote"><blockquote class="blockquote">
<p>Returns a new instance of an anonymous (inner) class.
The syntax is similar to <code class="literal">define-class</code>.
</p>
<div class="literallayout"><p><a class="indexterm" name="idp48466704"></a><a name="meta-object-field-or-method-decl"></a><em class="replaceable"><code>object-field-or-method-decl</code></em> <code class="literal">::=</code> <a class="link" href="Objects-Classes-and-Modules.html#meta-object-field-decl"><em class="replaceable"><code>object-field-decl</code></em></a> | <a class="link" href="Objects-Classes-and-Modules.html#meta-method-decl"><em class="replaceable"><code>method-decl</code></em></a><br>
<a class="indexterm" name="idp48471472"></a><a name="meta-object-field-decl"></a><em class="replaceable"><code>object-field-decl</code></em> <code class="literal">::=</code> <code class="literal"><span class="bold"><strong>(</strong></span></code><a class="link" href="Objects-Classes-and-Modules.html#meta-field-name"><em class="replaceable"><code>field-name</code></em></a> (<a class="link" href="Objects-Classes-and-Modules.html#meta-annotation"><em class="replaceable"><code>annotation</code></em></a> | <a class="link" href="Types.html#meta-opt-type-specifier"><em class="replaceable"><code>opt-type-specifier</code></em></a> | <a class="link" href="Objects-Classes-and-Modules.html#meta-field-option"><em class="replaceable"><code>field-option</code></em></a>)*  [<a class="link" href="Objects-Classes-and-Modules.html#meta-object-init"><em class="replaceable"><code>object-init</code></em></a>] <code class="literal"><span class="bold"><strong>)</strong></span></code><br>
<a class="indexterm" name="idp48480816"></a><a name="meta-object-init"></a><em class="replaceable"><code>object-init</code></em> <code class="literal">::=</code> <a class="link" href="Syntax.html#meta-expression"><em class="replaceable"><code>expression</code></em></a><br>
</p></div>
<p>Returns a new instance of a unique (anonymous) class.
The class inherits from the list of <em class="replaceable"><code>supers</code></em>, where at most one of the
elements should be the base class being extended from, and the rest
are interfaces.
</p>
<p>This is roughly equivalent to:
</p>
<pre class="screen">(begin
  (define-simple-class <em class="replaceable"><code>hname</code></em> (<em class="replaceable"><code>supers</code></em> ...) <em class="replaceable"><code>field-or-method-decl</code></em> ...)
  (make <em class="replaceable"><code>hname</code></em>))
</pre>
<p>A <em class="replaceable"><code>field-decl</code></em> is as for <code class="literal">define-class</code>, except
that we also allow an abbreviated syntax.
Each <em class="replaceable"><code>field-decl</code></em> declares a public instance field.
If <em class="replaceable"><code>object-finit</code></em> is given, it is an expression whose value
becomes the initial value of the field.
The <em class="replaceable"><code>object-init</code></em> is evaluated at the same time as the <code class="literal">object</code>
expression is evaluated,
in a scope where all the <em class="replaceable"><code>field-name</code></em>s are visible.
</p>
<p>A <em class="replaceable"><code>method-decl</code></em> is as for <code class="literal">define-class</code>.
</p>
</blockquote></div>
</div>
<p><a name="SAM-conversion"></a>
</p>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Lambda-as-shorthand-for-anonymous-class"></a>Lambda as shorthand for anonymous class</h4></div></div></div>
<p>An anonymous class is commonly used in the Java platform where a
function language would use a lambda expression.
Examples are call-back handlers, events handlers, and <code class="literal">run</code> methods.
In these cases Kawa lets you use a lambda expression as a short-hand
for an anonymous class.  For example:
</p>
<pre class="screen">(button:addActionListener
  (lambda (e) (do-something)))
</pre>
<p>is equivalent to:
</p>
<pre class="screen">(button:addActionListener
  (object (java.awt.event.ActionListener)
    ((actionPerformed (e ::java.awt.event.ActionEvent))::void
     (do-something))))
</pre>
<p>This is possible when the required type is an interface or
abstract class with a Single (exactly one) Abstract Methods.
Such a class is sometypes called a <em class="firstterm">SAM-type</em>, and the
conversion from a lambda expression to an anonymous class
is sometimes called <em class="firstterm">SAM-conversion</em>.
</p>
<p>Note that Kawa can also infer the parameter and return types
of a method that overrides a method in a super-class.
</p>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="Enumerations"></a>Enumeration types</h3></div></div></div>
<p>An enumeration type is a set of named atomic enumeration values
that are distinct from other values.  You define the type
using <code class="literal">define-enum</code>, and you reference enumeration values
using colon notation:
</p>
<pre class="screen">(define-enum colors (red blue green))
(define favorite-color colors:green)
</pre>
<p>Displaying an enum just prints the enum name,
but readable output using <code class="literal">write</code> (or the <code class="literal">~s</code> <code class="literal">format</code>
specifier) prepends the type name:
</p>
<pre class="screen">(format "~a" favorite-color) ⇒ "green"
(format "~s" favorite-color) ⇒ "colors:green"
</pre>
<p>The static <code class="literal">values</code> method returns a Java array of the enumeration
values, in declaration order, while <code class="literal">ordinal</code> yields the index
of an enumeration value:
</p>
<pre class="screen">(colors:values) ⇒ [red blue green]
((colors:values) 1) ⇒ blue
(favorite-color:ordinal) ⇒ 2
</pre>
<p>If you invoke the enumeration type as a function,
it will map the name (as a string) to the corresponding value.
(This uses the <code class="literal">valueOf</code> method.)
</p>
<pre class="screen">(colors "red") ⇒ red
(colors "RED") ⇒ throws IllegalArgumentException
(eq? favorite-color (colors:valueOf "green")) ⇒ #t
</pre>
<p>Kawa enumerations are based on Java enumerations.
Thus the above is similar to a Java5 <code class="literal">enum</code> declaration,
and the type <code class="literal">colors</code> above extends <code class="literal">java.lang.Enum</code>.
</p>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48515552"></a><code class="function">define-enum</code><em class="replaceable"><code> enum-type-name</code></em> <em class="replaceable"><code>option-pair</code></em><em class="replaceable"><code>...</code></em><em class="replaceable"><code> <code class="literal"><span class="bold"><strong>(</strong></span></code></code></em><em class="replaceable"><code>enum-value-name</code></em><em class="replaceable"><code> ...</code></em><em class="replaceable"><code><code class="literal"><span class="bold"><strong>)</strong></span></code></code></em> <em class="replaceable"><code>field-or-method-decl</code></em><em class="replaceable"><code>...</code></em></p>
<div class="blockquote"><blockquote class="blockquote"><p>This declares a new enumeration type <em class="replaceable"><code>enum-type-name</code></em>,
whose enumerations values are the <em class="replaceable"><code>enum-value-name</code></em> list.
You can specify extra options and members using
<em class="replaceable"><code>option-pair</code></em> and <em class="replaceable"><code>field-or-method-decl</code></em>,
which are as in <code class="literal">define-simple-class</code>.
(The <em class="replaceable"><code>define-enum</code></em> syntax is similar to a
<code class="literal">define-simple-class</code> that extends <code class="literal">java.lang.Enum</code>.)
</p></blockquote></div>
</div>
<p>(Note that R6RS has a separate Enumerations library <code class="literal">(rnrs enum)</code>.
Unfortunately, this is not compatible with standard Java enums.
R6RS enums are simple symbols, which means you cannot distinguish
two enum values from different enumeration types if they have the
same value, nor from a vanilla symbol.  That makes them less useful.)
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="Annotations"></a>Annotations of declarations</h3></div></div></div>
<p>The Java platform lets you associate with each declaration zero or more
<a class="ulink" href="http://download.oracle.com/javase/1.5.0/docs/guide/language/annotations.html" target="_top">annotations</a>.
They provide an extensible mechanism to associate properties
with declarations.
Kawa support for annotations is not complete (the most important
functionality missing is being able to declare annotation types),
but is fairly functional.
Here is a simple example illustrating use of
<a class="ulink" href="http://jcp.org/en/jsr/detail?id=222" target="_top">JAXB annotations</a>:
an <code class="literal">XmlRootElement</code> annotation on a class,
and an <code class="literal">XmlElement</code> annotation on a field:
</p>
<pre class="screen">(define-alias XmlRootElement javax.xml.bind.annotation.XmlRootElement)
(define-alias XmlElement javax.xml.bind.annotation.XmlElement)
(define-simple-class Bib ( ) (@XmlRootElement name: "bib")
  (books (@XmlElement name: "book" type: Book) ::java.util.ArrayList))
(define-simple-class Book () ...)
</pre>
<p><a class="ulink" href="http://per.bothner.com/blog/2011/Using-JAXB-annotations" target="_top">This tutorial</a>
explains the JAXB example in depth.
</p>
<p>Here is the syntax:
</p>
<div class="literallayout"><p><a class="indexterm" name="idp48536096"></a><a name="meta-annotation"></a><em class="replaceable"><code>annotation</code></em> <code class="literal">::=</code> <code class="literal"><span class="bold"><strong>(@</strong></span></code><a class="link" href="Objects-Classes-and-Modules.html#meta-annotation-typename"><em class="replaceable"><code>annotation-typename</code></em></a> <a class="link" href="Objects-Classes-and-Modules.html#meta-annotations-element-values"><em class="replaceable"><code>annotations-element-values</code></em></a><code class="literal"><span class="bold"><strong>)</strong></span></code><br>
<a class="indexterm" name="idp48542752"></a><a name="meta-annotations-element-values"></a><em class="replaceable"><code>annotations-element-values</code></em> <code class="literal">::=</code> <a class="link" href="Objects-Classes-and-Modules.html#meta-annotation-element-value"><em class="replaceable"><code>annotation-element-value</code></em></a><br>
  | <a class="link" href="Objects-Classes-and-Modules.html#meta-annotation-element-pair"><em class="replaceable"><code>annotation-element-pair</code></em></a> ...<br>
<a class="indexterm" name="idp48547792"></a><a name="meta-annotation-element-pair"></a><em class="replaceable"><code>annotation-element-pair</code></em> <code class="literal">::=</code> <a class="link" href="Symbols-and-namespaces.html#meta-keyword"><em class="replaceable"><code>keyword</code></em></a> <a class="link" href="Objects-Classes-and-Modules.html#meta-annotation-element-value"><em class="replaceable"><code>annotation-element-value</code></em></a><br>
<a class="indexterm" name="idp48552368"></a><a name="meta-annotation-element-value"></a><em class="replaceable"><code>annotation-element-value</code></em> <code class="literal">::=</code> <a class="link" href="Syntax.html#meta-expression"><em class="replaceable"><code>expression</code></em></a><br>
<a class="indexterm" name="idp48556048"></a><a name="meta-annotation-typename"></a><em class="replaceable"><code>annotation-typename</code></em> <code class="literal">::=</code> <a class="link" href="Syntax.html#meta-expression"><em class="replaceable"><code>expression</code></em></a><br>
</p></div>
<p>An <em class="replaceable"><code>annotations-element-values</code></em> consisting of just
a single <em class="replaceable"><code>annotation-element-value</code></em> is equivalent to an
<em class="replaceable"><code>annotation-element-pair</code></em> with a <code class="literal">value:</code> keyword.
</p>
<p>Each <em class="replaceable"><code>keyword</code></em> must correspond to the name of
an element (a zero-argument method) in the annotation type.
The corresponding <em class="replaceable"><code>annotation-element-value</code></em> must be compatible with the
element type (return type of the method) of the annotation type.
</p>
<p>Allowed element types are of the following kinds:
</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; ">
<li class="listitem" style="list-style-type: disc"><p>Primitive types, where the <em class="replaceable"><code>annotation-element-value</code></em> must
be number or boolean coercible to the element type.
</p></li>
<li class="listitem" style="list-style-type: disc"><p>Strings, where the <em class="replaceable"><code>annotation-element-value</code></em> is normally a string literal.
</p></li>
<li class="listitem" style="list-style-type: disc"><p>Classes, where the <em class="replaceable"><code>annotation-element-value</code></em> is normally
a classname.
</p></li>
<li class="listitem" style="list-style-type: disc"><p>Enumeration types. The value usually has the form <code class="literal"><em class="replaceable"><code>ClassName</code></em>:<em class="replaceable"><code>enumFieldname</code></em></code>.
</p></li>
<li class="listitem" style="list-style-type: disc"><p>Nested annotation types, where the  <em class="replaceable"><code>annotation-element-value</code></em> must
be a compatible <em class="replaceable"><code>annotation</code></em> value.
</p></li>
<li class="listitem" style="list-style-type: disc"><p>An array of one of the allowable types.
An array constructor expression works, but using the
square bracket syntax is recommended.
</p></li>
</ul></div>
<p>Annotations are usually used in declarations,
where they are required to be “constant-folded” to compile-time
constant annotation values.
This is so they can be written to class files.
However, in other contexts an annotation can be used as an expression
with general sub-expressions evaluated at run-time:
</p>
<pre class="screen">(define bk-name "book")
(define be (@XmlElement name: bk-name type: Book))
(be:name) ⇒ "book"
</pre>
<p>(This may have limited usefulness:  There are some bugs, including
lack of support for default values for annotation elements.
These bugs can be fixed if someone reports a need for
runtime construction of annotation values.)
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="Module-classes"></a>Modules and how they are compiled to classes</h3></div></div></div>
<p>A <em class="firstterm">module</em> is a set of definitions that the module <em class="firstterm">exports</em>,
as well as some <em class="firstterm">actions</em> (expressions evaluated for their side effect).
The top-level forms in a Scheme source file compile a module;
the source file is the <em class="firstterm">module source</em>.
When Kawa compiles the module source, the result is the
<em class="firstterm">module class</em>.  Each exported definition is translated to
a public field in the module class.
</p>
<p>You can declare a class using <code class="literal">define-simple-class</code>
with the same name as the module class, for example the
following in a file named <code class="literal">foo.scm</code>:
</p>
<pre class="screen">(define-simple-class foo ...)
</pre>
<p>In this case the defined class will serve dual-purpose as the module class.
</p>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Name-visibility"></a>Name visibility</h4></div></div></div>
<p>The definitions that a module exports are accessible to other modules.
These are the "public" definitions, to use Java terminology.
By default, all the identifiers declared at the top-level of a module
are exported, except those defined using <code class="literal">define-private</code>.
(If compiling with the <code class="literal">--main</code> flag,
then by default no identifiers are exported.)
However, a major purpose of using modules is to control the set of
names exported.  One reason is to reduce the chance of accidental
name conflicts between separately developed modules.  An even more
important reason is to enforce an interface:  Client modules should
only use the names that are part of a documented interface, and should
not use internal implementation procedures (since those may change).
</p>
<p>If there is a <code class="literal">module-export</code> (or <code class="literal">export</code>)
declaration in the module, then only those names listed are exported.
There can be more than one <code class="literal">module-export</code>, and they can be
anywhere in the Scheme file.  The recommended style has
a single <code class="literal">module-export</code> near the beginning of the file.
</p>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48590016"></a><code class="function">module-export</code><em class="replaceable"><code> <a class="link" href="Objects-Classes-and-Modules.html#meta-export-spec"><em class="replaceable"><code>export-spec</code></em></a></code></em><em class="replaceable"><code>^*</code></em></p>
<p class="synopsis"><a class="indexterm" name="idp48593792"></a><code class="function">export</code><em class="replaceable"><code> <a class="link" href="Objects-Classes-and-Modules.html#meta-export-spec"><em class="replaceable"><code>export-spec</code></em></a></code></em><em class="replaceable"><code>^*</code></em></p>
<div class="blockquote"><blockquote class="blockquote">
<p>The forms <code class="literal">export</code> and <code class="literal">module-export</code> are equivalent.
(The older Kawa name is <code class="literal">module-export</code>;
<code class="literal">export</code> comes from R7RS.)
Either form specifies a list of identifiers which
can be made visible to other libraries or programs.
</p>
<div class="literallayout"><p><a class="indexterm" name="idp48600800"></a><a name="meta-export-spec"></a><em class="replaceable"><code>export-spec</code></em> <code class="literal">::=</code> <em class="replaceable"><code>identifier</code></em><br>
  | <code class="literal"><span class="bold"><strong>(rename</strong></span></code> <a class="link" href="Syntax.html#meta-identifier"><em class="replaceable"><code>identifier</code></em></a>_1 <a class="link" href="Syntax.html#meta-identifier"><em class="replaceable"><code>identifier</code></em></a>_2<code class="literal"><span class="bold"><strong>)</strong></span></code><br>
</p></div>
<p>In the former variant, an <em class="replaceable"><code>identifier</code></em> names a single binding
defined within or imported into the library, where the
external name for the export is the same as the name of
the binding within the library.
A <code class="literal">rename</code> spec exports the
binding defined within or imported into the library and
named by <em class="replaceable"><code>identifier</code></em>_1,
using <em class="replaceable"><code>identifier</code></em>_2 as the external name.
</p>
<p>Note that it is an error if there is no definition for <em class="replaceable"><code>identifier</code></em>
(or <em class="replaceable"><code>identifier</code></em>_1)
in the current module, or if it is defined using <code class="literal">define-private</code>.
</p>
</blockquote></div>
</div>
<p>In this module, <code class="literal">fact</code> is public and <code class="literal">worker</code> is private:
</p>
<pre class="screen">(module-export fact)
(define (worker x) ...)
(define (fact x) ...)
</pre>
<p>Alternatively, you can write:
</p>
<pre class="screen">(define-private (worker x) ...)
(define (fact x) ...)
</pre>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="How-a-module-becomes-a-class"></a>How a module becomes a class</h4></div></div></div>
<p>If you want to just use a Scheme module as a module (i.e. <code class="literal">load</code>
or <code class="literal">require</code> it), you don't care how it gets translated
into a module class.  However, Kawa gives you some control over how this
is done, and you can use a Scheme module to define a class which
you can use with other Java classes.  This style of class definition
is an alternative to <code class="literal">define-class</code>,
which lets you define classes and instances fairly conveniently.
</p>
<p>The default name of the module class is the main part of the
filename of the Scheme source file (with directories and extensions
sripped off).  That can be overridden by the <code class="literal">-T</code> Kawa
command-line flag.  The package-prefix specified by the <code class="literal">-P</code>
flag is prepended to give the fully-qualified class name.
</p>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48623488"></a><code class="function">module-name</code><em class="replaceable"><code> name</code></em></p>
<p class="synopsis"><a class="indexterm" name="idp48626064"></a><code class="function">module-name</code><em class="replaceable"><code> &lt;name&gt;</code></em></p>
<div class="blockquote"><blockquote class="blockquote"><p>Sets the name of the generated class, overriding the default.
If there is no ‘<code class="literal">.</code>’ in the <em class="replaceable"><code>name</code></em>, the package-prefix
(specified by the <code class="literal">-P</code> Kawa command-line flag) is prepended.
</p></blockquote></div>
</div>
<p>By default, the base class of the generated module class is unspecified;
you cannot count on it being more specific than <code class="literal">Object</code>.
However, you can override it with <code class="literal">module-extends</code>.
</p>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48633456"></a><code class="function">module-extends</code><em class="replaceable"><code> class</code></em></p>
<div class="blockquote"><blockquote class="blockquote"><p>Specifies that the class generated from the immediately surrounding
module should extend (be a sub-class of) the class <code class="literal">&lt;<em class="replaceable"><code>class</code></em>&gt;</code>.
</p></blockquote></div>
</div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48638208"></a><code class="function">module-implements</code><em class="replaceable"><code> interface</code></em><em class="replaceable"><code> ...</code></em></p>
<div class="blockquote"><blockquote class="blockquote"><p>Specifies that the class generated from the immediately surrounding
module should implement the interfaces listed.
</p></blockquote></div>
</div>
<p>Note that the compiler does <span class="emphasis"><em>not</em></span> currently check that all the
abstract methods requires by the base class or implemented interfaces
are actually provided, and have the correct signatures.  This will
hopefully be fixed, but for now, if you are forgot a method, you will
probably get a verifier error
</p>
<p>For each top-level exported definition the compiler creates a
corresponding public field with a similar (mangled) name.
By default, there is some indirection:  The value of the Scheme variable
is not that of the field itself.  Instead, the field is a
<code class="literal">gnu.mapping.Symbol</code> object, and the value Scheme variable is
defined to be the value stored in the <code class="literal">Symbol</code>.
Howewer, if you specify an explicit type, then the field will
have the specified type, instead of being a <code class="literal">Symbol</code>.
The indirection using <code class="literal">Symbol</code> is also avoided if you use
<code class="literal">define-constant</code>.
</p>
<p>If the Scheme definition defines a procedure (which is not re-assigned
in the module), then the compiler assumes the variable as bound as a
constant procedure.  The compiler generates one or more methods
corresponding to the body of the Scheme procedure. It also generates
a public field with the same name; the value of the field is an
instance of a subclass of <code class="literal">&lt;gnu.mapping.Procedure&gt;</code> which when
applied will execute the correct method (depending on the actual arguments).
The field is used when the procedure used as a value (such as being passed
as an argument to <code class="literal">map</code>), but when the compiler is able to do so,
it will generate code to call the correct method directly.
</p>
<p>You can control the signature of the generated method by declaring
the parameter types and the return type of the method.  See the
applet (see <a class="xref" href="Running.html#Applet-compilation" title="Kawa: Compiling to an applet">the section called “Compiling to an applet”</a>) example for how this can be done.
If the procedures has optional parameters, then the compiler will
generate multiple methods, one for each argument list length.
(In rare cases the default expression may be such that this is
not possible, in which case an "variable argument list" method
is generated instead.  This only happens when there is a nested
scope <span class="emphasis"><em>inside</em></span> the default expression, which is very contrived.)
If there are <code class="literal">#!keyword</code> or <code class="literal">#!rest</code> arguments, the compiler
generate a "variable argument list" method.  This is a method whose
last parameter is either an array or a <code class="literal">&lt;list&gt;</code>, and whose
name has <code class="literal">$V</code> appended to indicate the last parameter is a list.
</p>
<p>Top-leval macros (defined using either <code class="literal">define-syntax</code>
or <code class="literal">defmacro</code>) create a field whose type is currently a sub-class of
<code class="literal">kawa.lang.Syntax</code>;  this allows importing modules to detect
that the field is a macro and apply the macro at compile time.
</p>
<p>Unfortunately, the Java class verifier does not allow fields to have
arbitrary names.  Therefore, the name of a field that represents a
Scheme variable is "mangled" (see <a class="xref" href="Objects-Classes-and-Modules.html#Mangling" title="Kawa: Mapping Scheme names to Java names">the section called “Mapping Scheme names to Java names”</a>) into an acceptable Java name.
The implementation can recover the original name of a field <code class="literal">X</code>
as <code class="literal">((gnu.mapping.Named) X).getName()</code> because all the standard
compiler-generate field types implemented the <code class="literal">Named</code> interface.
</p>
<p><a name="static-or-non-modules"></a>
</p>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Static-vs-non-static-modules"></a>Static vs non-static modules</h4></div></div></div>
<p>There are two kinds of module class:
A <em class="firstterm">static module</em> is a class (or gets compiled to a class)
all of whose public fields a static, and that does not have a
public constructor.  A JVM can only have a single global instance of
a static module.
An <em class="firstterm">instance module</em> has a public default constructor,
and usually has at least one non-static public field.
There can be multiple instances
of an instance module; each instance is called a <em class="firstterm">module instance</em>.
However, only a single instance of a module can be <em class="firstterm">registered</em>
in an environment, so in most cases there is only a single
instance of instance modules.  Registering an instance in an environment
means creating a binding mapping a magic name (derived from the class name)
to the instance.
</p>
<p>In fact, any Java class class that has the properties of either
an instance module or a static module, is a module, and can be
loaded or imported as such;  the class need not have written
using Scheme.
</p>
<p>You can control whether a module is compiled to a static or
a non-static class using either a command-line flag to the compiler,
or using the <code class="literal">module-static</code> special form.
</p>
<div class="variablelist"><dl class="variablelist">
<dt class="term"><code class="literal">--module-static</code></dt>
<dd><p>If no <code class="literal">module-static</code> is specified, generate a static module
(as if <code class="literal">(module-static #t)</code> were specified).
This is (now) the default.
</p></dd>
<dt class="term"><code class="literal">--module-nonstatic</code></dt>
<dt class="term"><code class="literal">--no-module-static</code></dt>
<dd><p>If no <code class="literal">module-static</code> is specified, generate a non-static module
(as if <code class="literal">(module-static #f)</code> were specified).
This used to be the default.
</p></dd>
<dt class="term"><code class="literal">--module-static-run</code></dt>
<dd><p>If no <code class="literal">module-static</code> is specified, generate a static module
(as if <code class="literal">(module-static 'init-run)</code> were specified).
</p></dd>
</dl></div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48678304"></a><code class="function">module-static</code><em class="replaceable"><code> name</code></em><em class="replaceable"><code> ...</code></em></p>
<p class="synopsis"><a class="indexterm" name="idp48681168"></a><code class="function">module-static</code><em class="replaceable"><code> <code class="literal">#t</code></code></em></p>
<p class="synopsis"><a class="indexterm" name="idp48684240"></a><code class="function">module-static</code><em class="replaceable"><code> <code class="literal">#f</code></code></em></p>
<p class="synopsis"><a class="indexterm" name="idp48687312"></a><code class="function">module-static</code><em class="replaceable"><code> <code class="literal">'init-run</code></code></em></p>
<div class="blockquote"><blockquote class="blockquote">
<p>Control whether the generated fields and methods are static.
If <code class="literal">#t</code>  or <code class="literal">'init-run</code> is specified, then the module will be a
static module, <span class="emphasis"><em>all</em></span> definitions will be static.
If <code class="literal">'init-run</code> is specified, in addition the module body
is evaluated in the class's static initializer.
(Otherwise, it is run the first time it is <code class="literal">require</code>'d.)
Otherwise, the module is an instance module.  However, the <em class="replaceable"><code>name</code></em>s
that are explicitly listed will be compiled to static fields and methods.
If <code class="literal">#f</code> is specified, then all exported names will
be compiled to non-static (instance) fields and methods.
</p>
<p>By default, if no <code class="literal">module-static</code> is specified:
</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>If there is a <code class="literal">module-extends</code> or <code class="literal">module-implements</code>
declaration, or one of the <code class="literal">--applet</code> or <code class="literal">--servlet</code>
command-line flags was specified, then <code class="literal">(module-static #f)</code> is implied.
</p></li>
<li class="listitem"><p>If one of the command-line flags
<code class="literal">--no-module-static</code>, <code class="literal">--module-nonstatic</code>,
<code class="literal">--module-static</code>, or <code class="literal">--module-static-run</code> was specified,
then the default is <code class="literal">#f</code>, <code class="literal">#f</code>, <code class="literal">#t</code>, or <code class="literal">'init-run</code>,
respectively.
</p></li>
<li class="listitem"><p>Otherwise the default is <code class="literal">(module-static #t)</code>.
(It used to be <code class="literal">(module-static #f)</code> in older Kawa versions.)
</p></li>
</ol></div>
<p>Note <code class="literal">(module-static #t)</code> usually produces more efficient
code, and is recommended if a module contains only procedure or macro
definitions.  (This may become the default.)
However, a static module means that all environments in a JVM
share the same bindings, which you may not want if you use
multiple top-level environments.
</p>
</blockquote></div>
</div>
<p>The top-level actions of a module will get compiled to a <code class="literal">run</code>
method.  If there is an explicit <code class="literal">method-extends</code>, then the
module class will also automatically implement <code class="literal">java.lang.Runnable</code>.
(Otherwise, the class does not implement <code class="literal">Runnable</code>, since in that
case the <code class="literal">run</code> method return an <code class="literal">Object</code> rather than <code class="literal">void</code>.
This will likely change.)
</p>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Module-options"></a>Module options</h4></div></div></div>
<p>Certain compilation options can be be specified <span class="emphasis"><em>either</em></span>
on the command-line when compiling, or in the module itself.
</p>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48719968"></a><code class="function">module-compile-options</code> [<em class="replaceable"><code>key</code></em><em class="replaceable"><code><code class="literal"><span class="bold"><strong>:</strong></span></code></code></em><em class="replaceable"><code> value</code></em>]<em class="replaceable"><code> ...</code></em></p>
<div class="blockquote"><blockquote class="blockquote">
<p>This sets the value of the <code class="literal">key</code> option to <code class="literal">value</code>
for the current module (source file).  It takes effect as
soon it is seen during the first macro-expansion pass,
and is active thereafter (unless overridden by <code class="literal">with-compile-options</code>).
</p>
<p>The <em class="replaceable"><code>key:</code></em> is one of the supported option names
(The ending colon makes it a Kawa keyword). Valid
option keys are:
</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p><code class="literal"><span class="bold"><strong>main:</strong></span></code> - Generate an application, with a main method.
</p></li></ul></div>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p><code class="literal"><span class="bold"><strong>full-tailcalls:</strong></span></code> - Use a calling convention that supports proper tail recursion.
</p></li></ul></div>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; ">
<li class="listitem" style="list-style-type: disc"><p><code class="literal"><span class="bold"><strong>warn-undefined-variable:</strong></span></code> - Warn if no compiler-visible binding for a variable.
</p></li>
<li class="listitem" style="list-style-type: disc"><p><code class="literal"><span class="bold"><strong>warn-unknown-member:</strong></span></code> - Warn if referencing an unknown method or field.
</p></li>
<li class="listitem" style="list-style-type: disc"><p><code class="literal"><span class="bold"><strong>warn-invoke-unknown-method:</strong></span></code> - Warn if invoke calls an unknown method (subsumed by warn-unknown-member).
</p></li>
<li class="listitem" style="list-style-type: disc"><p><code class="literal"><span class="bold"><strong>warn-unused:</strong></span></code> - Warn if a variable is usused or code never executed.
</p></li>
<li class="listitem" style="list-style-type: disc"><p><code class="literal"><span class="bold"><strong>warn-unreachable:</strong></span></code> - Warn if this code can never be executed.
</p></li>
<li class="listitem" style="list-style-type: disc"><p><code class="literal"><span class="bold"><strong>warn-void-used:</strong></span></code> - Warn if an expression depends on the value of a void sub-expression (one that never returns a value).
</p></li>
<li class="listitem" style="list-style-type: disc"><p><code class="literal"><span class="bold"><strong>warn-as-error:</strong></span></code> - Treat a compilation warning as if it were an error.
</p></li>
</ul></div>
<p>The <em class="replaceable"><code>value</code></em> must be a literal value: either a boolean
(<code class="literal">#t</code> or <code class="literal">#f</code>), a number, or a string,
depending on the <em class="replaceable"><code>key</code></em>.
(All the options so far are boolean options.)
</p>
<pre class="screen">(module-compile-options warn-undefined-variable: #t)
;; This causes a warning message that y is unknown.
(define (func x) (list x y))
</pre>
</blockquote></div>
</div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48749344"></a><code class="function">with-compile-options</code> [<em class="replaceable"><code>key:</code></em><em class="replaceable"><code> value</code></em>]<em class="replaceable"><code> ...</code></em><em class="replaceable"><code> body</code></em></p>
<div class="blockquote"><blockquote class="blockquote">
<p>Similar to <code class="literal">module-compile-options</code>, but the option
is only active within <em class="replaceable"><code>body</code></em>.
</p>
<p>The module option key <code class="literal">main:</code> has no effect when applied
to a particular body via the <code class="literal">with-compile-options</code> syntax.
</p>
<pre class="screen">(define (func x)
  (with-compile-options warn-invoke-unknown-method: #f
    (invoke x 'size)))
</pre>
</blockquote></div>
</div>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Requiring-(importing)-a-module"></a>Requiring (importing) a module</h4></div></div></div>
<p><a name="require"></a>
You can import a module into the current namespace with <code class="literal">require</code>.
</p>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48760608"></a><code class="function">require</code><em class="replaceable"><code> <code class="literal"><span class="bold"><strong>'</strong></span></code></code></em><em class="replaceable"><code>featureName</code></em></p>
<p class="synopsis"><a class="indexterm" name="idp48764368"></a><code class="function">require</code><em class="replaceable"><code> classname</code></em> [<em class="replaceable"><code><code class="literal"><span class="bold"><strong>"</strong></span></code></code></em><em class="replaceable"><code>sourcepath</code></em><em class="replaceable"><code><code class="literal"><span class="bold"><strong>"</strong></span></code></code></em>]</p>
<p class="synopsis"><a class="indexterm" name="idp48769664"></a><code class="function">require</code><em class="replaceable"><code> <code class="literal"><span class="bold"><strong>"</strong></span></code></code></em><em class="replaceable"><code>sourcepath</code></em><em class="replaceable"><code><code class="literal"><span class="bold"><strong>"</strong></span></code></code></em></p>
<div class="blockquote"><blockquote class="blockquote">
<p>Search for a matching module (class), and add the names
exported by that module to the current set of visible names.
Normally, the module is specified using <em class="replaceable"><code>classname</code></em>.
The module can be static module (all public fields must be static),
or an instance module (it has a public default constructor).
</p>
<p>If the module is a instance module and if no module instance for that class
has been registered in the current environment, then a new instance
is created and registered (using a "magic" identifier).
If the module class either inherits from <code class="literal">gnu.expr.ModuleBody</code>
or implements <code class="literal">java.lang.Runnable</code> then the corresponding <code class="literal">run</code>
method is executed.  (This is done <span class="emphasis"><em>after</em></span> the instance is
registered so that cycles can be handled.)  These actions (creating,
registering, and running the module instance) are done both at compile
time and at run time, if necessary.
</p>
<p>All the public fields of the module class are then incorporated
in the current set of local visible names in the current module.
(This is for both instance and static modules.)
This is done at compile time - no new bindings are created at run-time
(except for the magic binding used to register the module instance),
and the imported bindings are private to the current module.
References to the imported bindings will be compiled as field
references, using the module instance (except for static fields).
</p>
<p>If a <code class="literal"><code class="literal"><span class="bold"><strong>"</strong></span></code><em class="replaceable"><code>sourcepath</code></em><code class="literal"><span class="bold"><strong>"</strong></span></code></code> is specified then
that is used to locate the source file for the module, and if necessary,
compile it.
</p>
<p>If a <code class="literal">'<em class="replaceable"><code>featurename</code></em></code> is specified then the
<em class="replaceable"><code>featurename</code></em> is looked up (at compile time) in the "feature table"
which yields the implementing <em class="replaceable"><code>classname</code></em>.
</p>
</blockquote></div>
</div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48786400"></a><code class="function">import</code><em class="replaceable"><code> <a class="link" href="Objects-Classes-and-Modules.html#meta-import-set"><em class="replaceable"><code>import-set</code></em></a></code></em><em class="replaceable"><code>^*</code></em></p>
<div class="blockquote"><blockquote class="blockquote">
<p>Similar functionality as <code class="literal">require</code>, but specified by R6RS.
</p>
<div class="literallayout"><p><a class="indexterm" name="idp48791296"></a><a name="meta-import-set"></a><em class="replaceable"><code>import-set</code></em> <code class="literal">::=</code> <a class="link" href="Objects-Classes-and-Modules.html#meta-library-reference"><em class="replaceable"><code>library-reference</code></em></a><br>
  | <code class="literal"><span class="bold"><strong>(library</strong></span></code> <a class="link" href="Objects-Classes-and-Modules.html#meta-library-reference"><em class="replaceable"><code>library-reference</code></em></a> <code class="literal"><span class="bold"><strong>)</strong></span></code><br>
  | <code class="literal"><span class="bold"><strong>(only</strong></span></code> <a class="link" href="Objects-Classes-and-Modules.html#meta-import-set"><em class="replaceable"><code>import-set</code></em></a> <em class="replaceable"><code>identifier</code></em>^*<code class="literal"><span class="bold"><strong>)</strong></span></code><br>
  | <code class="literal"><span class="bold"><strong>(except</strong></span></code> <a class="link" href="Objects-Classes-and-Modules.html#meta-import-set"><em class="replaceable"><code>import-set</code></em></a> <em class="replaceable"><code>identifier</code></em>^*<code class="literal"><span class="bold"><strong>)</strong></span></code><br>
  | <code class="literal"><span class="bold"><strong>(prefix</strong></span></code> <a class="link" href="Objects-Classes-and-Modules.html#meta-import-set"><em class="replaceable"><code>import-set</code></em></a> <em class="replaceable"><code>identifier</code></em> <code class="literal"><span class="bold"><strong>)</strong></span></code><br>
  | <code class="literal"><span class="bold"><strong>(rename</strong></span></code> <a class="link" href="Objects-Classes-and-Modules.html#meta-import-set"><em class="replaceable"><code>import-set</code></em></a> <code class="literal"><span class="bold"><strong>(</strong></span></code> <em class="replaceable"><code>identifier1</code></em> <em class="replaceable"><code>identifier2</code></em> <code class="literal"><span class="bold"><strong>)</strong></span></code>^*<code class="literal"><span class="bold"><strong>)</strong></span></code><br>
<a class="indexterm" name="idp48814800"></a><a name="meta-library-reference"></a><em class="replaceable"><code>library-reference</code></em> <code class="literal">::=</code> <code class="literal"><span class="bold"><strong>(</strong></span></code> <em class="replaceable"><code>identifier</code></em>^+ <code class="literal"><span class="bold"><strong>)</strong></span></code><br>
</p></div>
<p>A <em class="replaceable"><code>library-reference</code></em> is mapped to a class name by concatenating
all the identifiers, separated by dots.
For example:
</p>
<pre class="screen">(import (gnu kawa slib srfi37))
</pre>
<p>is equivalent to:
</p>
<pre class="screen">(require gnu.kawa.slib.srfi37)
</pre>
<p>By default, all of an imported library's exported bindings are made
visible within an importing library using the names given to the
bindings by the imported library.  The precise set of bindings to be
imported and the names of those bindings can be adjusted with the
<code class="literal">only</code>, <code class="literal">except</code>, <code class="literal">prefix</code>, and <code class="literal"> rename</code> forms as
described below.
</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem"><p>An <code class="literal">only</code> form produces a subset of the bindings from another
<em class="replaceable"><code>import-set</code></em>, including only the listed <em class="replaceable"><code>identifier</code></em>s.  The
included <em class="replaceable"><code>identifier</code></em>s must be in the original <em class="replaceable"><code>import-set</code></em>.
</p></li>
<li class="listitem"><p>An <code class="literal">except</code> form produces a subset of the bindings from another
<em class="replaceable"><code>import-set</code></em>, including all but the listed <em class="replaceable"><code>identifier</code></em>s.  All
of the excluded <em class="replaceable"><code>identifier</code></em>s must be in the original <em class="replaceable"><code>import-set</code></em>.
</p></li>
<li class="listitem"><p>A <code class="literal">prefix</code> form adds the <em class="replaceable"><code>identifier</code></em> prefix to each name from
another <em class="replaceable"><code>import-set</code></em>.
</p></li>
<li class="listitem">
<p>A <code class="literal">rename</code> form:
</p>
<pre class="screen">(rename (<em class="replaceable"><code>identifier1</code></em> <em class="replaceable"><code>identifier2</code></em>) …)
</pre>
<p>removes the bindings for <code class="literal"><em class="replaceable"><code>identifier1</code></em> …</code> to form an
intermediate <em class="replaceable"><code>import-set</code></em>, then adds the bindings back for the
corresponding <code class="literal"><em class="replaceable"><code>identifier2</code></em> …</code> to form the final
<em class="replaceable"><code>import-set</code></em>.  Each <em class="replaceable"><code>identifier1</code></em> must be in the original
<em class="replaceable"><code>import-set</code></em>, each <em class="replaceable"><code>identifier2</code></em> must not be in the
intermediate <em class="replaceable"><code>import-set</code></em>, and the <em class="replaceable"><code>identifier2</code></em>s must be
distinct.
</p>
</li>
</ul></div>
</blockquote></div>
</div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48844720"></a><code class="function">provide</code><em class="replaceable"><code> <code class="literal"><span class="bold"><strong>'</strong></span></code></code></em><em class="replaceable"><code>featurename</code></em></p>
<div class="blockquote"><blockquote class="blockquote"><p>Declare that <code class="literal">'<em class="replaceable"><code>featurename</code></em></code> is available.
A following <code class="literal">cond-expand</code> in this scope will match <em class="replaceable"><code>featurename</code></em>.
</p></blockquote></div>
</div>
<p>Using <code class="literal">require</code> and <code class="literal">provide</code> with <em class="replaceable"><code>featurename</code></em>s is
similar to the same-named macros in SLib, Emacs, and Common Lisp.
However, in Kawa these are not functions, but instead they
are syntax forms that are processed at compile time.  That is
why only quoted <em class="replaceable"><code>featurename</code></em>s are supported.
This is consistent with Kawa emphasis on compilation and
static binding.
</p>
<p>For some examples, you may want to look in the <code class="literal">gnu/kawa/slib</code>
directory.
</p>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="Record-types"></a>Record types</h3></div></div></div>
<p>The <code class="literal">define-record-type</code> form can be used for creating new data
types, called record types. A predicate, constructor, and field
accessors and modifiers are defined for each record type.
The <code class="literal">define-record-type</code> feature is specified
by <a class="ulink" href="http://srfi.schemers.org/srfi-9/srfi-9.html" target="_top">SRFI-9</a>,
which is implemented by many modern Scheme implementations.
</p>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48860144"></a><code class="function">define-record-type</code> <em class="replaceable"><code>type-name</code></em> (<em class="replaceable"><code>constructor-name</code></em> <em class="replaceable"><code>field-tag</code></em><em class="replaceable"><code> ...</code></em>) <em class="replaceable"><code>predicate-name</code></em> (<em class="replaceable"><code>field-tag</code></em> <em class="replaceable"><code>accessor-name</code></em> [<em class="replaceable"><code>modifier-name</code></em>])<em class="replaceable"><code> ...</code></em></p>
<div class="blockquote"><blockquote class="blockquote">
<p>The form <code class="literal">define-record-type</code> is generative: each use creates a new
record type that is distinct from all existing types, including other
record types and Scheme's predefined types. Record-type definitions may
only occur at top-level (there are two possible semantics for `internal'
record-type definitions, generative and nongenerative, and no consensus
as to which is better).
</p>
<p>An instance of <code class="literal">define-record-type</code> is equivalent to the following definitions:
</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem"><p>The <em class="replaceable"><code>type-name</code></em> is bound to a representation of the record type
itself.
</p></li>
<li class="listitem"><p>The <em class="replaceable"><code>constructor-name</code></em> is bound to a procedure that takes
as many arguments as there are <em class="replaceable"><code>field-tag</code></em>s in the
<code class="literal">(<em class="replaceable"><code>constructor-name</code></em> ...)</code> subform and returns
a new <em class="replaceable"><code>type-name</code></em> record. Fields whose tags are listed with
<em class="replaceable"><code>constructor-name</code></em> have the corresponding argument as their initial
value. The initial values of all other fields are unspecified.
</p></li>
<li class="listitem"><p>The <em class="replaceable"><code>predicate-name</code></em> is a predicate that returns <code class="literal">#t</code>
when given a value returned by <em class="replaceable"><code>constructor-name</code></em>
and <code class="literal">#f</code> for everything else.
</p></li>
<li class="listitem"><p>Each <em class="replaceable"><code>accessor-name</code></em> is a procedure that takes a record of
type <em class="replaceable"><code>type-name</code></em> and returns the current value of the corresponding field.
It is an error to pass an accessor a value which is not a record of the
appropriate type.
</p></li>
<li class="listitem"><p>Each <em class="replaceable"><code>modifier-name</code></em> is a procedure that takes a record of
type <em class="replaceable"><code>type-name</code></em> and a value which becomes the new value of
the corresponding field.
The result (in Kawa) is the empty value <code class="literal">#!void</code>.
It is an error to pass a
modifier a first argument which is not a record of the appropriate type.
</p></li>
</ul></div>
<p>Set!ing the value of any of these identifiers has no effect on the
behavior of any of their original values.
</p>
</blockquote></div>
</div>
<p>Here is an example of how you can define a record type named <code class="literal">pare</code>
with two fields <code class="literal">x</code> and <code class="literal">y</code>:
</p>
<pre class="screen">(define-record-type pare
  (kons x y)
  pare?
  (x kar set-kar!)
  (y kdr))
</pre>
<p>The above defines <code class="literal">kons</code> to be a constructor,
<code class="literal">kar</code> and <code class="literal">kdr</code> to be accessors,
<code class="literal">set-kar!</code> to be a modifier,
and <code class="literal">pare?</code> to be a predicate for <code class="literal">pare</code>s.
</p>
<pre class="screen">(pare? (kons 1 2))        ⇒ #t
(pare? (cons 1 2))        ⇒ #f
(kar (kons 1 2))          ⇒ 1
(kdr (kons 1 2))          ⇒ 2
(let ((k (kons 1 2)))
  (set-kar! k 3)
  (kar k))                ⇒ 3
</pre>
<p>Kawa compiles the record type into a nested class.
If the <code class="literal">define-record-type</code> appears at module level,
the result is a class that is a member of the module class.
For example if the above <code class="literal">pare</code> class is define in a
module <code class="literal">parelib</code>, then the result is a class
named <code class="literal">pare</code> with the internal JVM name <code class="literal">parelib$pare</code>.
The <code class="literal">define-record-type</code> can appear inside a procedure,
in which case the result is an inner class.
</p>
<p>The nested class has a name derived from
the <em class="replaceable"><code>type-name</code></em>.  If the <em class="replaceable"><code>type-name</code></em> is valid Java class name,
that becomes the name of the Java class.  If the <em class="replaceable"><code>type-name</code></em> has
the form <code class="literal">&lt;<em class="replaceable"><code>name</code></em>&gt;</code> (for example <code class="literal">&lt;pare&gt;</code>), then <em class="replaceable"><code>name</code></em>
is used, if possible, for the Java class name.  Otherwise, the name
of the Java class is derived by "mangling" the <em class="replaceable"><code>type-name</code></em>.
In any case, the package is the same as that of the surrounding module.
</p>
<p>Kawa generates efficient code for the resulting functions,
without needing to use run-time reflection.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="Dynamic-records"></a>Creating New Record Types On-the-fly</h3></div></div></div>
<p>Calling the <code class="literal">make-record-type</code> procedure creates a new record data
type at run-time, without any compile-time support.
It is primarily provided for compatibility; in most cases it is better
to use the <code class="literal">define-record-type</code> form (see <a class="xref" href="Objects-Classes-and-Modules.html#Record-types" title="Kawa: Record types">the section called “Record types”</a>).
</p>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48905280"></a><code class="function">make-record-type</code><em class="replaceable"><code> type-name</code></em><em class="replaceable"><code> field-names</code></em></p>
<div class="blockquote"><blockquote class="blockquote"><p>Returns a <em class="firstterm">record-type descriptor</em>, a value representing a new data
type disjoint from all others.  The <em class="replaceable"><code>type-name</code></em> argument must be a
string, but is only used for debugging purposes (such as the printed
representation of a record of the new type).  The <em class="replaceable"><code>field-names</code></em>
argument is a list of symbols naming the <em class="firstterm">fields</em> of a record of the
new type.  It is an error if the list contains any duplicates.
</p></blockquote></div>
</div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48915568"></a><code class="function">record-constructor</code><em class="replaceable"><code> rtd</code></em> [<em class="replaceable"><code>field-names</code></em>]</p>
<div class="blockquote"><blockquote class="blockquote"><p>Returns a procedure for constructing new members of the type represented
by <em class="replaceable"><code>rtd</code></em>.  The returned procedure accepts exactly as many arguments
as there are symbols in the given list, <em class="replaceable"><code>field-names</code></em>; these are
used, in order, as the initial values of those fields in a new record,
which is returned by the constructor procedure.  The values of any
fields not named in that list are unspecified.  The <em class="replaceable"><code>field-names</code></em>
argument defaults to the list of field names in the call to
<code class="literal">make-record-type</code> that created the type represented by <em class="replaceable"><code>rtd</code></em>;
if the <em class="replaceable"><code>field-names</code></em> argument is provided, it is an error if it
contains any duplicates or any symbols not in the default list.
</p></blockquote></div>
</div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48924656"></a><code class="function">record-predicate</code><em class="replaceable"><code> rtd</code></em></p>
<div class="blockquote"><blockquote class="blockquote"><p>Returns a procedure for testing membership in the type represented by
<em class="replaceable"><code>rtd</code></em>.  The returned procedure accepts exactly one argument and
returns a true value if the argument is a member of the indicated record
type; it returns a false value otherwise.
</p></blockquote></div>
</div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48932224"></a><code class="function">record-accessor</code><em class="replaceable"><code> rtd</code></em><em class="replaceable"><code> field-name</code></em></p>
<div class="blockquote"><blockquote class="blockquote"><p>Returns a procedure for reading the value of a particular field of a
member of the type represented by <em class="replaceable"><code>rtd</code></em>.  The returned procedure
accepts exactly one argument which must be a record of the appropriate
type; it returns the current value of the field named by the symbol
<em class="replaceable"><code>field-name</code></em> in that record.  The symbol <em class="replaceable"><code>field-name</code></em> must be a
member of the list of field-names in the call to <code class="literal">make-record-type</code>
that created the type represented by <em class="replaceable"><code>rtd</code></em>.
</p></blockquote></div>
</div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48938624"></a><code class="function">record-modifier</code><em class="replaceable"><code> rtd</code></em><em class="replaceable"><code> field-name</code></em></p>
<div class="blockquote"><blockquote class="blockquote"><p>Returns a procedure for writing the value of a particular field of a
member of the type represented by <em class="replaceable"><code>rtd</code></em>.  The returned procedure
accepts exactly two arguments: first, a record of the appropriate type,
and second, an arbitrary Scheme value; it modifies the field named by
the symbol <em class="replaceable"><code>field-name</code></em> in that record to contain the given value.
The returned value of the modifier procedure is unspecified.  The symbol
<em class="replaceable"><code>field-name</code></em> must be a member of the list of field-names in the call
to <code class="literal">make-record-type</code> that created the type represented by <em class="replaceable"><code>rtd</code></em>.
</p></blockquote></div>
</div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48945248"></a><code class="function">record?</code><em class="replaceable"><code> obj</code></em></p>
<div class="blockquote"><blockquote class="blockquote"><p>Returns a true value if <em class="replaceable"><code>obj</code></em> is a record of any type and a false
value otherwise.
</p></blockquote></div>
</div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48949232"></a><code class="function">record-type-descriptor</code><em class="replaceable"><code> record</code></em></p>
<div class="blockquote"><blockquote class="blockquote"><p>Returns a record-type descriptor representing the type of the given
record.  That is, for example, if the returned descriptor were passed to
<code class="literal">record-predicate</code>, the resulting predicate would return a true
value when passed the given record.
</p></blockquote></div>
</div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48953664"></a><code class="function">record-type-name</code><em class="replaceable"><code> rtd</code></em></p>
<div class="blockquote"><blockquote class="blockquote"><p>Returns the type-name associated with the type represented by rtd.  The
returned value is <code class="literal">eqv?</code> to the <em class="replaceable"><code>type-name</code></em> argument given in
the call to <code class="literal">make-record-type</code> that created the type represented by
<em class="replaceable"><code>rtd</code></em>.
</p></blockquote></div>
</div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp48959568"></a><code class="function">record-type-field-names</code><em class="replaceable"><code> rtd</code></em></p>
<div class="blockquote"><blockquote class="blockquote"><p>Returns a list of the symbols naming the fields in members of the type
represented by <em class="replaceable"><code>rtd</code></em>.  The returned value is <code class="literal">equal?</code> to the
field-names argument given in the call to <code class="literal">make-record-type</code> that
created the type represented by <em class="replaceable"><code>rtd</code></em>.
</p></blockquote></div>
</div>
<p>Records are extensions of the class <code class="literal">Record</code>.
These procedures use the Java 1.1 reflection facility.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="Method-operations"></a>Calling Java methods from Scheme</h3></div></div></div>
<p>You can call a Java method as if it were a Scheme procedure
using various mechanisms.
</p>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Calling-static-methods-using-colon-notation"></a>Calling static methods using colon notation</h4></div></div></div>
<p>The easiest way to invoke a static method is to use
<a class="link" href="Syntax.html#Colon-notation" title="Kawa: Property access using colon notation">colon notation</a>, specifically:
</p>
<div class="literallayout"><p><code class="literal"><span class="bold"><strong>(</strong></span></code><em class="replaceable"><code>class-expression</code></em><code class="literal"><span class="bold"><strong>:</strong></span></code><em class="replaceable"><code>method-name</code></em> <em class="replaceable"><code>argument</code></em> ...<code class="literal"><span class="bold"><strong>)</strong></span></code><br>
</p></div>
<p>The <em class="replaceable"><code>class-expression</code></em> can be a class in the current lexical
scope, such as a class defined using <code class="literal">define-simple-class</code>:
</p>
<pre class="screen">(define-simple-class MyClass ()
  ((add2 x y) allocation: 'static (+ x y)))
(MyClass:add2 3 4) ⇒ 7
</pre>
<p>Often <em class="replaceable"><code>class-expression</code></em> is a fully-qualified class name:
</p>
<pre class="screen">(java.lang.Math:sqrt 9.0) ⇒ 3.0
</pre>
<p>This is only allowed when the name is of a class that exists
and is accessible both at compile-time and run-time,
and the name is not otherwise lexically bound.
</p>
<p>You can also use a defined alias:
</p>
<pre class="screen">(define-alias jlMath java.lang.Math)
(jlMath:sqrt 16.0) ⇒ 4.0
</pre>
<p>You can even evaluate <em class="replaceable"><code>class-expression</code></em> at run-time
(in which case Kawa may have to use slower reflection):
</p>
<pre class="screen">(let ((math java.lang.Math)) math:sqrt 9.0) ⇒ 3.0
</pre>
<p>Here <code class="literal">java.lang.Math</code> evaluates to a <code class="literal">java.lang.Class</code>
instance for the named class (like Java's <code class="literal">java.lang.Class.class</code>,
again assuming the class exists and is accessible both at compile-time and
run-time, and the name is not otherwise lexically bound.
</p>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Calling-instance-methods-using-colon-notation"></a>Calling instance methods using colon notation</h4></div></div></div>
<p>The syntax is:
</p>
<div class="literallayout"><p><code class="literal"><span class="bold"><strong>(</strong></span></code><em class="replaceable"><code>instance</code></em><code class="literal"><span class="bold"><strong>:</strong></span></code><em class="replaceable"><code>method-name</code></em> <em class="replaceable"><code>argument</code></em> ...<code class="literal"><span class="bold"><strong>)</strong></span></code><br>
</p></div>
<p>This invokes the method named <em class="replaceable"><code>method-name</code></em>
with the evaluated  <em class="replaceable"><code>instance</code></em> as the target object
and the evaluated <em class="replaceable"><code>argument</code></em>s as the method arguments.
</p>
<p>For example:
</p>
<pre class="screen">((list 9 8 7):toString) ⇒ "(9 8 7)"
([5 6 7]:get 2) ⇒ 7
</pre>
<p>This older syntax is also available:
</p>
<div class="literallayout"><p><code class="literal"><span class="bold"><strong>(*:</strong></span></code><em class="replaceable"><code>method-name</code></em> <em class="replaceable"><code>instance</code></em> <em class="replaceable"><code>argument</code></em> ...<code class="literal"><span class="bold"><strong>)</strong></span></code><br>
</p></div>
<p>For example:
</p>
<pre class="screen">(*:toString (list 9 8 7))
</pre>
<p>You can also name the class explicitly:
</p>
<div class="literallayout"><p><code class="literal"><span class="bold"><strong>(</strong></span></code><em class="replaceable"><code>class-expression</code></em><code class="literal"><span class="bold"><strong>:</strong></span></code><em class="replaceable"><code>method-name</code></em> <em class="replaceable"><code>instance</code></em> <em class="replaceable"><code>argument</code></em> ...<code class="literal"><span class="bold"><strong>)</strong></span></code><br>
</p></div>
<p>For example:
</p>
<pre class="screen">(java.util.List:get [5 6 7] 2) ⇒ 7
</pre>
<p>Using an explicit class is like coercing the <em class="replaceable"><code>instance</code></em>:
</p>
<div class="literallayout"><p><code class="literal"><span class="bold"><strong>(*:</strong></span></code><em class="replaceable"><code>method-name</code></em> <code class="literal"><span class="bold"><strong>(as </strong></span></code><em class="replaceable"><code>class-expression</code></em> <em class="replaceable"><code>instance</code></em> <code class="literal"><span class="bold"><strong>)</strong></span></code><em class="replaceable"><code>argument</code></em> ...<code class="literal"><span class="bold"><strong>)</strong></span></code><br>
</p></div>
<p>Note that for some special values,
including <code class="literal">java.lang.Class</code> instances, you can't
use the compact form of <a class="link" href="Syntax.html#Colon-notation" title="Kawa: Property access using colon notation">colon notation</a>
where the <em class="replaceable"><code>instance</code></em> is before the comma:
</p>
<pre class="screen">(java.lang.Integer:getDeclaredField "MAX_VALUE") ⇒ <em class="wordasword">error</em>
</pre>
<p>This is because in this case we look for a static member
of <code class="literal">java.lang.Integer</code>
(at least as currently defined and implemented),
while we want an instance member of <code class="literal">java.lang.Class</code>.
In those cases you can use one of
these alternative forms, which all return the same
<code class="literal">java.lang.reflect.Field</code> result:
</p>
<pre class="screen">(*:getDeclaredField java.lang.Integer "MAX_VALUE")
(java.lang.Class:getDeclaredField java.lang.Integer "MAX_VALUE")
(invoke java.lang.Integer 'getDeclaredField "MAX_VALUE")
</pre>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Method-names"></a>Method names</h4></div></div></div>
<p>The method to invoke is selected using the specified
method name and argments.  If specified name is not a Java name,
it is "mangled" (see <a class="xref" href="Objects-Classes-and-Modules.html#Mangling" title="Kawa: Mapping Scheme names to Java names">the section called “Mapping Scheme names to Java names”</a>) into a valid Java name.
All accessible methods whose names match are considered.
Methods that match after appending <code class="literal">$V</code> or <code class="literal">$X</code> or <code class="literal">$V$X</code>
are also considered.  A <code class="literal">$V</code> suffix matches a variable
number of arguments:  any excess arguments are collect into an
<code class="literal">gnu.lists.LList</code> or a Java array (depending on the final parameter type).
A <code class="literal">$X</code> specifies that the method expects an extra implicit
<code class="literal">CallContext</code> parameter.  In that case the method's result is written
to the <code class="literal">CallContext</code>, so the method result type must be <code class="literal">void</code>.
</p>
<p>(Kawa may compile a procedure with a <code class="literal">#!rest</code> or keyword args
whose name is <code class="literal"><em class="replaceable"><code>fn</code></em></code> to a method named <code class="literal"><em class="replaceable"><code>fn</code></em>$V</code>.
It adds an implicit parameter for the extra arguments.
By default this extra extra parameter is a Scheme list.
You can specify a Java array type instead, in which case the method is
named <code class="literal"><em class="replaceable"><code>fn</code></em></code> without the <code class="literal">$V</code>,
and instead it is marked as a Java-5 varargs method.
The array element type must be compatible with all the extra arguments.)
</p>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Invoking-a-method-with-the-invoke-function"></a>Invoking a method with the <code class="literal">invoke</code> function</h4></div></div></div>
<p>If you prefer, you can instead use the following functions.
(There is also an older deprecated lower-level interface
(see <a class="xref" href="">???</a>.)
</p>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp49036944"></a><code class="function">invoke-static</code><em class="replaceable"><code> class</code></em><em class="replaceable"><code> name</code></em><em class="replaceable"><code> args</code></em><em class="replaceable"><code> ...</code></em></p>
<div class="blockquote"><blockquote class="blockquote">
<p>The <em class="replaceable"><code>class</code></em> can be a <code class="literal">java.lang.Class</code>, a
<code class="literal">gnu.bytecode.ClassType</code>, or a <code class="literal">symbol</code> or <code class="literal">string</code>
that names a Java class.  The <em class="replaceable"><code>name</code></em> can be <code class="literal">symbol</code> or
<code class="literal">string</code> that names one or more methods in the Java class.
</p>
<p>Any accessible methods (static or instance) in the specified <em class="replaceable"><code>class</code></em>
(or its super-classes) that match "<em class="replaceable"><code>name</code></em>" or "<em class="replaceable"><code>name</code></em>$V" collectively
form a generic procedure.  When the procedure is applied to the argument list,
the most specific applicable method is chosen depending on the
argument list;  that method is then
called with the given arguments.  Iff the method is an instance method,
the first actual argument is used as the <code class="literal">this</code> argument.  If there are
no applicable methods (or no methods at all!), or there is no "best"
method, <code class="literal">WrongType</code> is thrown.
</p>
<p>An example:
</p>
<pre class="screen">(invoke-static java.lang.Thread 'sleep 100)
</pre>
<p>The behavior of interpreted code and compiled code is not
identical, though you should get the same result either way
unless you have designed the classes rather strangely.  The
details will be nailed down later, but the basic idea is that
the compiler will "inline" the <code class="literal">invoke-static</code> call
if it can pick a single "best" matching method.
</p>
</blockquote></div>
</div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp49053312"></a><code class="function">invoke</code><em class="replaceable"><code> object</code></em><em class="replaceable"><code> name</code></em><em class="replaceable"><code> args</code></em><em class="replaceable"><code> ...</code></em></p>
<div class="blockquote"><blockquote class="blockquote">
<p>The <em class="replaceable"><code>name</code></em> can be <code class="literal">&lt;symbol&gt;</code> or
<code class="literal">&lt;string&gt;</code> that names one or more methods in the Java class.
</p>
<p>Any accessible methods (static or instance) in the specified <em class="replaceable"><code>class</code></em>
(or its super-classes) that match "<em class="replaceable"><code>name</code></em>" or "<em class="replaceable"><code>name</code></em>$V" collectively
form a generic procedure.  When the procedure is applied to the argument list,
the most specific applicable method is chosen depending on the
argument list;  that method is then
called with the given arguments.  Iff the method is an instance method,
the <em class="replaceable"><code>object</code></em> is used as the <code class="literal">this</code> argument;
otherwise <em class="replaceable"><code>object</code></em> is prepended to the <em class="replaceable"><code>args</code></em> list.  If there are
no applicable methods (or no methods at all!), or there is no "best"
method, <code class="literal">WrongType</code> is thrown.
</p>
<p>The behavior of interpreted code and compiled code is not
indentical, though you should get the same result either way
unless you have designed the classes rather strangely.  The
details will be nailed down later, but the basic idea is that
the compiler will "inline" the <code class="literal">invoke-static</code> call
if it can pick a single "best" matching method.
</p>
<p>If the compiler cannot determine the method to call (assuming
the method name is constant), the compiler has to generate code
at run-time to find the correct method.  This is much slower,
so the compiler will print a warning.  To avoid a waning, you can
use a type declaration, or insert a cast:
</p>
<pre class="screen">(invoke (as java.util.Date my-date) 'setDate cur-date)
</pre>
<p>or
</p>
<pre class="screen">(let ((my-date ::java.util.Date (calculate-date))
      (cur-date ::int (get-cur-date)))
  (invoke my-date 'setDate cur-date))
</pre>
</blockquote></div>
</div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp49068880"></a><code class="function">invoke-special</code><em class="replaceable"><code> class</code></em><em class="replaceable"><code> receiver-object</code></em><em class="replaceable"><code> name</code></em><em class="replaceable"><code> arg</code></em><em class="replaceable"><code> ...</code></em></p>
<div class="blockquote"><blockquote class="blockquote">
<p>The <em class="replaceable"><code>class</code></em> can be a <code class="literal">java.lang.Class</code>, a
<code class="literal">gnu.bytecode.ClassType</code>, or a <code class="literal">symbol</code> or <code class="literal">string</code>
that names a Java class.
The <em class="replaceable"><code>name</code></em> can be <code class="literal">symbol</code> or
<code class="literal">string</code> that names one or more methods in the Java class.
</p>
<p>This procedure is very similar to <code class="literal">invoke</code> and <code class="literal">invoke-static</code>
and invokes the specified method, ignoring any methods in subclasses
that might overide it.  One interesting use is to invoke a method in
your super-class like the Java language <code class="literal">super</code> keyword.
</p>
<p>Any methods in the specified <em class="replaceable"><code>class</code></em> that match "<em class="replaceable"><code>name</code></em>" or
"<em class="replaceable"><code>name</code></em>$V" collectively form a generic procedure.  That generic
procedure is then applied as in <code class="literal">invoke</code> using the
<code class="literal">receiver-object</code> and the arguments (if any).
</p>
<p>The compiler must be able to inline this procedure (because you cannot
force a specific method to be called using reflection).  Therefore the
<em class="replaceable"><code>class</code></em> and <em class="replaceable"><code>name</code></em> must resolve at compile-time to a specific
method.
</p>
<pre class="screen">(define-simple-class &lt;MyClass&gt; (&lt;java.util.Date&gt;)
  ((get-year) :: &lt;int&gt;
   (+ (invoke-special &lt;java.util.Date&gt; (this) 'get-year)) 1900)
  ((set-year (year :: &lt;int&gt;)) :: &lt;void&gt;
   (invoke-special &lt;java.util.Date&gt; (this) 'set-year (- year 1900))))
</pre>
</blockquote></div>
</div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp49087472"></a><code class="function">class-methods</code><em class="replaceable"><code> class</code></em><em class="replaceable"><code> name</code></em></p>
<div class="blockquote"><blockquote class="blockquote">
<p>Return a generic function containing those methods of <em class="replaceable"><code>class</code></em>
that match the name <em class="replaceable"><code>name</code></em>, in the sense of <code class="literal">invoke-static</code>.
Same as:
</p>
<pre class="screen">(lambda args (apply invoke-static (cons class (cons name args))))
</pre>
</blockquote></div>
</div>
<p>Some examples using these functions are ‘<code class="literal">vectors.scm</code>’
and ‘<code class="literal">characters.scm</code>’ the directory ‘<code class="literal">kawa/lib</code>’ in
the Kawa sources.
</p>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Using-a-namespace-prefix"></a>Using a namespace prefix</h4></div></div></div>
<p><span class="emphasis"><em>This way of invoking a method is deprecated.</em></span>
</p>
<p>You can use <code class="literal">define-namespace</code> to define an alias for a Java class:
</p>
<pre class="screen">(define-namespace Int32 "class:java.lang.Integer")
</pre>
<p>In this example the name <code class="literal">Int32</code> is a <em class="firstterm">namespace alias</em>
for the namespace whose full name is <code class="literal">"class:java.lang.Integer"</code>.
The full name should be the 6 characters <code class="literal">"class:"</code> followed
by the fully-qualified name of a Java class.
</p>
<p>Instead of a <em class="replaceable"><code>vamespace-uri</code></em> you can use a variable that names
a class, usually of the form <code class="literal">&lt;<em class="replaceable"><code>classname</code></em>&gt;</code>.
The following is equivalent to the above:
</p>
<pre class="screen">(define-namespace Int32 &lt;java.lang.Integer&gt;)
</pre>
<p>However, there is one important difference: The <code class="literal">&lt;<em class="replaceable"><code>classname</code></em>&gt;</code>
is first searched in the lexical scope.
It may resolve to a class defined in the current compilation unit
(perhaps defined using <code class="literal">define-simple-class</code>),
or imported from another module,
or an alias (such as from <code class="literal">define-alias</code>).
Only if <code class="literal">&lt;<em class="replaceable"><code>classname</code></em>&gt;</code> is <span class="emphasis"><em>not</em></span> found in the current
scope is it tried as the class name <em class="replaceable"><code>classname</code></em>.
</p>
<p>You can name a method using a <em class="firstterm">qualified name</em> containing a colon.
The part of the name before the colon is a namespace alias (in
this case <code class="literal">Int32</code>), and the part of the name after the colon is the
method name.  For example:
</p>
<pre class="screen">(Int32:toHexString 255) ⇒ "ff"
</pre>
<p>This invokes the static method <code class="literal">toHexString</code> in the
Java class <code class="literal">java.lang.Integer</code>, passing it the argument <code class="literal">255</code>,
and returning the String <code class="literal">"ff"</code>.
</p>
<p>The general syntax is
</p>
<pre class="screen">(<em class="replaceable"><code>prefix</code></em>:<em class="replaceable"><code>method-name</code></em> <em class="replaceable"><code>arg</code></em> ...)
</pre>
<p>This invokes the method named <em class="replaceable"><code>method-name</code></em> in the class corresponding
to <em class="replaceable"><code>prefix</code></em>, and the <em class="replaceable"><code>arg</code></em>s are the method arguments.
</p>
<p>You can use the method name <code class="literal">new</code> to construct new objects:
</p>
<pre class="screen">(Int32:new '|255|)
</pre>
<p>This is equivalent to the Java expression <code class="literal">new Integer("255")</code>.
You can also write:
</p>
<pre class="screen">(Int32:new "255")
</pre>
<p>You can also call instance methods using a namespace prefix:
</p>
<pre class="screen">(Int32:doubleValue (Int32:new "00255"))
</pre>
<p>This returns the <code class="literal">double</code> value <code class="literal">255.0</code>.
</p>
<p>As a shorthand, you can use the name of a Java class instead of a
namespace alias:
</p>
<pre class="screen">(java.lang.Integer:toHexString 255)
(java.lang.Object:toString some-value)
</pre>
<p>If Kawa sees a qualified name with a prefix that is not defined <span class="emphasis"><em>and</em></span>
that matches the name of a known class, then Kawa will automatically
treat the prefix
as a nickname for namespace uri like <code class="literal">class:java.lang.Integer</code>.
Both conditions should be true at both compile-time and run-time.
However, using an explicit <code class="literal">define-namespace</code> is recommended.
</p>
<p>As a final shorthand you can use an identifier in handle brackets,
such as an existing type alias like <code class="literal">&lt;list&gt;</code>.
The following are all equivalent:
</p>
<pre class="screen">(&lt;list&gt;:list3 'a 'b 'c)
</pre>
<p>This is equivalent to:
</p>
<pre class="screen">(define-namespace <em class="replaceable"><code>prefix</code></em> &lt;list&gt;
(<em class="replaceable"><code>prefix</code></em>:list3 'a 'b 'c)
</pre>
<p>for some otherwise-unused <em class="replaceable"><code>prefix</code></em>.
</p>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="Allocating-objects"></a>Allocating objects</h3></div></div></div>
<p>The recommended way to create an instance of a type <em class="replaceable"><code>T</code></em>
is to “call” <em class="replaceable"><code>T</code></em> as if it were a function, with the
arguments used to initialize the object.
If <code class="literal">T</code> is a class and <code class="literal">T</code> has a matching constructor,
then the arguments will used for constructor arguments:
</p>
<pre class="screen">(java.util.StringTokenizer "this/is/a/test" "/")
</pre>
<p>(You can think of the type <em class="replaceable"><code>T</code></em> as being
coerced to an instance-constructor function.)
</p>
<p>If <code class="literal">T</code> is a container or collection type,
then typically the arguments will be used to specify
the child or component values.
Many standard Scheme procedures fit this convention.
For example in Kawa <code class="literal">list</code> and <code class="literal">vector</code> evaluate to
types, rather than procedures as in standard Scheme,
but because types can be used as constructor functions it just works:
</p>
<pre class="screen">(list 'a (+ 3 4) 'c) ⇒ (a 7 c)
(vector 'a 'b 'c) ⇒ #(a b c)
</pre>
<p>Any class <code class="literal">T</code> that has a default constructor
and an <code class="literal">add</code> method can be initialized this way.
Examples are <code class="literal">java.util</code> collection classes,
and <code class="literal">jawa.awt</code> and <code class="literal">javax.swing</code> containers.
</p>
<pre class="screen">(java.util.ArrayList 11 22 33) ⇒ [11, 22, 333]
</pre>
<p>The above expression is equivalent to:
</p>
<pre class="screen">(let ((tmp (java.util.ArrayList)))
  (tmp:add 11)
  (tmp:add 22)
  (tmp:add 33)
  tmp)
</pre>
<p>Allocating Java arrays (see <a class="xref" href="Objects-Classes-and-Modules.html#Creating-new-Java-arrays">the section called “Using Java Arrays”</a>) uses a
similar pattern:
</p>
<pre class="screen">(int[] 2 3 5 7 11)
</pre>
<p>Sometimes you want to set some named property to an initial value.
You can do that using a keyword argument.  For example:
</p>
<pre class="screen">(javax.swing.JButton text: "Do it!" tool-tip-text: "do it")
</pre>
<p>This is equivalent to using <em class="firstterm">setter methods</em>:
</p>
<pre class="screen">(let ((tmp (javax.swing.JButton)))
  (tmp:setText "Do it!")
  (tmp:setToolTipText "do it")
  tmp)
</pre>
<p>A keyword argument <code class="literal"><em class="replaceable"><code>key-name</code></em></code><code class="literal"><span class="bold"><strong>:</strong></span></code> can
can translated to either a <code class="literal"><code class="literal"><span class="bold"><strong>set</strong></span></code><em class="replaceable"><code>KeyName</code></em><code class="literal"><span class="bold"><strong>:</strong></span></code></code>
or a  <code class="literal"><code class="literal"><span class="bold"><strong>add</strong></span></code><em class="replaceable"><code>KeyName</code></em><code class="literal"><span class="bold"><strong>:</strong></span></code></code> method.
The latter makes it convenient to add listeners:
</p>
<pre class="screen">(javax.swing.JButton
  text: "Do it!"
  action-listener:
   (object (java.awt.event.ActionListener)
     ((actionPerformed e) (do-the-action))))
</pre>
<p>This is equivalent to:
</p>
<pre class="screen">(let ((tmp (javax.swing.JButton)))
  (tmp:setText "Do it!")
  (tmp:addActionListener
    (object (java.awt.event.ActionListener)
      ((actionPerformed e) (do-the-action))))
  tmp)
</pre>
<p>Making use of so-called “SAM-conversion” (see <a class="xref" href="Objects-Classes-and-Modules.html#SAM-conversion">the section called “Anonymous classes”</a>)
 makes it even more convenient:
</p>
<pre class="screen">(javax.swing.JButton
  text: "Do it!"
  action-listener:
   (lambda (e) (do-the-action)))
</pre>
<p>The general case allows for a mix of
constructor arguments, property keywords, and child values:
</p>
<div class="literallayout"><p><em class="replaceable"><code>class-type</code></em> <a class="link" href="Objects-Classes-and-Modules.html#meta-constructor-value"><em class="replaceable"><code>constructor-value</code></em></a>... <a class="link" href="Objects-Classes-and-Modules.html#meta-property-initializer"><em class="replaceable"><code>property-initializer</code></em></a>... <a class="link" href="Objects-Classes-and-Modules.html#meta-child-value"><em class="replaceable"><code>child-value</code></em></a>...<br>
<a class="indexterm" name="idp49168544"></a><a name="meta-constructor-value"></a><em class="replaceable"><code>constructor-value</code></em> <code class="literal">::=</code> <a class="link" href="Syntax.html#meta-expression"><em class="replaceable"><code>expression</code></em></a><br>
<a class="indexterm" name="idp49172096"></a><a name="meta-property-initializer"></a><em class="replaceable"><code>property-initializer</code></em> <code class="literal">::=</code> <a class="link" href="Symbols-and-namespaces.html#meta-keyword"><em class="replaceable"><code>keyword</code></em></a> <a class="link" href="Syntax.html#meta-expression"><em class="replaceable"><code>expression</code></em></a><br>
<a class="indexterm" name="idp49176672"></a><a name="meta-child-value"></a><em class="replaceable"><code>child-value</code></em> <code class="literal">::=</code> <a class="link" href="Syntax.html#meta-expression"><em class="replaceable"><code>expression</code></em></a><br>
</p></div>
<p>First an object is constructed with the <em class="replaceable"><code>constructor-value</code></em> arguments
(if any) passed to the object constructor;
then named properties (if any) are used to initialize named properties;
and then remaining arguments are used to add child values.
</p>
<p>There is an ambiguity if there is no <em class="replaceable"><code>property-initializer</code></em> -
we can't distinguish between a <em class="replaceable"><code>constructor-value</code></em>
and a <em class="replaceable"><code>child-value</code></em>.
In that case, if there is a matching constructor method, then all of the
arguments are constructor arguments;
otherwise, there must a default constructor, and all
of the arguments are <em class="replaceable"><code>child-value</code></em> arguments.
</p>
<p>There is a trick you can you if you need both
<em class="replaceable"><code>constructor-value</code></em> and <em class="replaceable"><code>child-value</code></em> arguments:
separate them with an “empty keyword” <code class="literal">||:</code>.
This matches a method named <code class="literal">add</code>, which means that
the next argument effectively a <em class="replaceable"><code>child-value</code></em> - as do
all the remaining arguments. Example:
</p>
<pre class="screen">(let ((vec #(1 2 3)))
  (java.util.ArrayList vec ||: 4 5 6))
  ⇒ [1, 2, 3, 4, 5, 6]
</pre>
<p>The compiler rewrites these allocations expression
to generated efficient bytecode, assuming that the “function”
being applied is a type known by the compiler.
Most of the above expressions also work if the type is applied
at run-time, in which case Kawa has to use slower reflection:
</p>
<pre class="screen">(define iarr int[])
(apply iarr (list 3 4 5)) ⇒ [3 4 5]
</pre>
<p>However <code class="literal">add<em class="replaceable"><code>Xxx</code></em></code> methods and SAM-conversion
are currently only recognized in the case of a class known at compile-time,
not at run-time.
</p>
<p>Here is a working Swing demo illustrating many of these techniques:
</p>
<pre class="screen">(define-alias JButton javax.swing.JButton)
(define-simple-class HBox (javax.swing.Box)
  ((*init*) (invoke-special javax.swing.Box (this) '*init* 0)))
(define-alias JFrame javax.swing.JFrame)
(define-alias Box javax.swing.Box)

(define value 0)

(define txt
  (javax.swing.JLabel
   text: "0"))

(define (set-value i)
  (set! value i)
  (set! txt:text (number-&gt;string i)))

(define fr
  (JFrame
     title: "Hello!"
     (Box 1#|VERTICAL|# ||:
      (javax.swing.Box:createGlue)
      txt
      (javax.swing.Box:createGlue)
      (HBox
       (JButton ;; uses 1-argument constructor
	"Decrement" ;; constructor argument
	tool-tip-text: "decrement"
	action-listener: (lambda (e) (set-value (- value 1))))
       (javax.swing.Box:createGlue)
       (JButton ;; uses 0-argument constructor
	text: "Increment"
	tool-tip-text: "increment"
	action-listener: (lambda (e) (set-value (+ value 1))))))))
(fr:setSize 200 100)
(set! fr:visible #t)
</pre>
<p>If you prefer, you can use the older <code class="literal">make</code> special function:
</p>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp49195424"></a><code class="function">make</code><em class="replaceable"><code> type</code></em><em class="replaceable"><code> args</code></em><em class="replaceable"><code> ...</code></em></p>
<div class="blockquote"><blockquote class="blockquote">
<p>Constructs a new object instance of the specified <em class="replaceable"><code>type</code></em>,
which must be either a <code class="literal">java.lang.Class</code> or a
<code class="literal">&lt;gnu.bytecode.ClassType&gt;</code>.
Equivalent to:
</p>
<pre class="screen"><em class="replaceable"><code>type</code></em> <em class="replaceable"><code>args</code></em> ...
</pre>
</blockquote></div>
</div>
<p>Another (semi-deprecated) function is to use the colon notation
with the <code class="literal">new</code> pseudo-function.
The following three are all equivalent:
</p>
<pre class="screen">(java.awt.Point:new x: 4 y: 3)
(make java.awt.Point: x: 4 y: 3)
(java.awt.Point x: 4 y: 3)
</pre>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="Field-operations"></a>Accessing object fields</h3></div></div></div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Accessing-static-fields-and-properties"></a>Accessing static fields and properties</h4></div></div></div>
<p>The recommmended way to access fields
uses the <a class="link" href="Syntax.html#Colon-notation" title="Kawa: Property access using colon notation">colon notation</a>.
For static fields and properties the following is recommended:
</p>
<div class="literallayout"><p><em class="replaceable"><code>class-expression</code></em><code class="literal"><span class="bold"><strong>:</strong></span></code><em class="replaceable"><code>field-name</code></em><br>
</p></div>
<p>For example:
</p>
<pre class="screen">java.lang.Integer:MAX_VALUE
</pre>
<p>A property with a <code class="literal">get</code> method is equivalent to a field.
The following are all equivalent:
</p>
<pre class="screen">java.util.Currency:available-currencies
java.util.Currency:availableCurrencies
(java.util.Currency:getAvailableCurrencies)
</pre>
<p>Just like for a method call, the <em class="replaceable"><code>class-expression</code></em>
can be a class in the current lexical scope,
a fully-qualified class name, or more generally an
expression that evaluates to a class.
</p>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Accessing-instance-fields-and-properties"></a>Accessing instance fields and properties</h4></div></div></div>
<p>The syntax is:
</p>
<div class="literallayout"><p><em class="replaceable"><code>instance</code></em><code class="literal"><span class="bold"><strong>:</strong></span></code><em class="replaceable"><code>field-name</code></em><br>
</p></div>
<p>The <em class="replaceable"><code>field-name</code></em> can of course be the name of an actual
object field, but it can also be the name of a property with
a zero-argument <code class="literal">get</code> method.
For example, if <code class="literal">cal</code> is a <code class="literal">java.util-Calendar</code> instance,
then the following are all equivalent:
</p>
<pre class="screen">cal:time-zone
cal:timeZone
(cal:getTimeZone)
(cal:get-time-zone)
</pre>
<p>You can use colon notation to assign to a field:
</p>
<pre class="screen">(set! cal:time-zone TimeZone:default)
</pre>
<p>which is equivalent to:
</p>
<pre class="screen">(cal:setTimeZone (TimeZone:getDefault))
</pre>
<p>A Java array only has the <code class="literal">length</code> field, plus the <code class="literal">class</code> property:
</p>
<pre class="screen">(int[] 4 5 6):length ⇒ 3
(int[] 4 5 6):class:name ⇒ "int[]"
</pre>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Using-field-and-static-field-methods"></a>Using field and static-field methods</h4></div></div></div>
<p>The following methods are useful in cases where colon notation
is ambiguous, for example where there are both fields and methods
with the same name.
You might also prefer as a matter of style, to
emphasise that a field is being accessed.
</p>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp49228080"></a><code class="function">field</code><em class="replaceable"><code> object</code></em><em class="replaceable"><code> fieldname</code></em></p>
<div class="blockquote"><blockquote class="blockquote">
<p>Get the instance field with the given <em class="replaceable"><code>fieldname</code></em> from the given
<em class="replaceable"><code>Object</code></em>.  Returns the value of the field, which must be accessible.
This procedure has a <code class="literal">setter</code>, and so can be used as the first
operand to <code class="literal">set!</code>.
</p>
<p>The field name is "mangled" (see <a class="xref" href="Objects-Classes-and-Modules.html#Mangling" title="Kawa: Mapping Scheme names to Java names">the section called “Mapping Scheme names to Java names”</a>) into a valid Java name.
If there is no accessible field whose name is <code class="literal">"<em class="replaceable"><code>fieldname</code></em>"</code>,
we look for a no-argument method whose name is
<code class="literal">"get<em class="replaceable"><code>Fieldname</code></em>"</code> (or <code class="literal">"is<em class="replaceable"><code>Fieldname</code></em>"</code> for a
boolean property).
</p>
<p>If <em class="replaceable"><code>object</code></em> is a primitive Java array, then <em class="replaceable"><code>fieldname</code></em> can only
be <code class="literal">'length</code>, and the result is the number of elements of the array.
</p>
</blockquote></div>
</div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp49241088"></a><code class="function">static-field</code><em class="replaceable"><code> class</code></em><em class="replaceable"><code> fieldname</code></em></p>
<div class="blockquote"><blockquote class="blockquote">
<p>Get the static field with the given <em class="replaceable"><code>fieldname</code></em> from the given
<em class="replaceable"><code>class</code></em>.  Returns the value of the field, which must be accessible.
This procedure has a <code class="literal">setter</code>, and so can be used as the first
operand to <code class="literal">set!</code>.
</p>
<p>If the <em class="replaceable"><code>fieldname</code></em> is the special name <code class="literal">class</code>,
then it returns the <code class="literal">java.lang.Class</code> object corresponding to
<em class="replaceable"><code>class</code></em> (which is usually a <code class="literal">gnu.bytecode.ClassType</code> object).
</p>
</blockquote></div>
</div>
<p>Examples:
</p>
<pre class="screen">(static-field java.lang.System 'err)
;; Copy the car field of b into a.
(set! (field a 'car) (field b 'car))
</pre>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp49251872"></a><code class="function">slot-ref</code><em class="replaceable"><code> object</code></em><em class="replaceable"><code> fieldname</code></em></p>
<div class="blockquote"><blockquote class="blockquote"><p>A synonym for <code class="literal">(field <em class="replaceable"><code>object</code></em> <em class="replaceable"><code>fieldname</code></em>)</code>.
</p></blockquote></div>
</div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp49257200"></a><code class="function">slot-set!</code><em class="replaceable"><code> object</code></em><em class="replaceable"><code> fieldname</code></em><em class="replaceable"><code> value</code></em></p>
<div class="blockquote"><blockquote class="blockquote"><p>A synonym for <code class="literal">(set! (field <em class="replaceable"><code>object</code></em> <em class="replaceable"><code>fieldname</code></em>) <em class="replaceable"><code>value</code></em>)</code>.
</p></blockquote></div>
</div>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Older-colon-dot-notation"></a>Older colon-dot notation</h4></div></div></div>
<p>There is older syntax where following the colon
there is field name a following the colon <span class="emphasis"><em>and</em></span> a period.
</p>
<p>To access an static field named <em class="replaceable"><code>field-name</code></em> use this syntax
</p>
<pre class="screen">(<em class="replaceable"><code>prefix</code></em>:.<em class="replaceable"><code>field-name</code></em> <em class="replaceable"><code>instance</code></em>)
</pre>
<p>The <em class="replaceable"><code>prefix</code></em> can be as discussed in See <a class="xref" href="Objects-Classes-and-Modules.html#Method-operations" title="Kawa: Calling Java methods from Scheme">the section called “Calling Java methods from Scheme”</a>.
Here are 5 equivalent ways:
</p>
<pre class="screen">(java.lang.Integer:.MAX_VALUE)
(&lt;java.lang.Integer&gt;:.MAX_VALUE)
(define-namespace Int32 &lt;java.lang.Integer&gt;)
(Int32:.MAX_VALUE)
(define-namespace Integer "class:java.lang.Integer")
(Integer:.MAX_VALUE)
(define-alias j.l.Integer java.lang.Integer)
(j.l.Integer:.MAX_VALUE)
</pre>
<p>You can set a static field using this syntax:
</p>
<pre class="screen">(set! (<em class="replaceable"><code>prefix</code></em>:.<em class="replaceable"><code>field-name</code></em>) <em class="replaceable"><code>new-value</code></em>)
</pre>
<p>The special field name <code class="literal">class</code> can be used to extract the
<code class="literal">java.lang.Class</code> object for a class-type.  For example:
</p>
<pre class="screen">(java.util.Vector:.class) ⇒ class java.util.Vector
</pre>
<p>To access a instance field named <em class="replaceable"><code>field-name</code></em> use the following syntax.
Note the period before the <em class="replaceable"><code>field-name</code></em>.
</p>
<pre class="screen">(*:.<em class="replaceable"><code>field-name</code></em> <em class="replaceable"><code>instance</code></em>)
</pre>
<p>This syntax works with <code class="literal">set!</code> - to set the field use this syntax:
</p>
<pre class="screen">(set! (*:.<em class="replaceable"><code>field-name</code></em> <em class="replaceable"><code>instance</code></em>) <em class="replaceable"><code>new-value</code></em>)
</pre>
<p>Here is an example:
</p>
<pre class="screen">(define p (list 3 4 5))
(*:.cdr p) ⇒ (4 5)
(set! (*:.cdr p) (list 6 7))
p ⇒ (3 6 7)
</pre>
<p>You can specify an explicit class:
</p>
<pre class="screen">(<em class="replaceable"><code>prefix</code></em>:.<em class="replaceable"><code>field-name</code></em> <em class="replaceable"><code>instance</code></em>)
</pre>
<p>If <em class="replaceable"><code>prefix</code></em> is bound to <code class="literal">&lt;<em class="replaceable"><code>class</code></em>&gt;</code>, then the above
is equivalent to:
</p>
<pre class="screen">(*:.<em class="replaceable"><code>field-name</code></em> (as &lt;<em class="replaceable"><code>class</code></em>&gt; <em class="replaceable"><code>instance</code></em>))
</pre>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="Mangling"></a>Mapping Scheme names to Java names</h3></div></div></div>
<p>Programs use "names" to refer to various values and procedures.
The definition of what is a "name" is different in different
programming languages.  A name in Scheme (and other Lisp-like
languages) can in principle contain any character (if using a
suitable quoting convention), but typically names consist of
"words" (one or more letters) separated by hyphens, such
as ‘<code class="literal">make-temporary-file</code>’.  Digits
and some special symbols are also used.  Standard Scheme
is case-insensitive;  this means that the names ‘<code class="literal">loop</code>’,
‘<code class="literal">Loop</code>’, and ‘<code class="literal">LOOP</code>’ are all the same name.  Kawa
is by default case-sensitive, but we recommend that you
avoid using upper-case letters as a general rule.
</p>
<p>The Java language and the Java virtual machine uses names for
classes, variables, fields and methods.  These names can
contain upper- and lower-case letters, digits, and the special
symbols ‘<code class="literal">_</code>’ and ‘<code class="literal">$</code>’.
</p>
<p>Given a name in a Scheme program,
Kawa needs to map that name into a valid Java name.  A typical
Scheme name such as ‘<code class="literal">make-temporary-file</code>’ is not a valid
Java name.  The convention for Java names is to use
"mixed-case" words, such as ‘<code class="literal">makeTemporaryFile</code>’.
So Kawa will translate a Scheme-style name into a Java-style
name.  The basic rule is simple:  Hyphens are dropped, and
a letter that follows a hyphen is translated to its
upper-case (actually "title-case") equivalent.  Otherwise,
letters are translated as is.
</p>
<p>Some special characters are handled specially.  A final ‘<code class="literal">?</code>’
is replaced by an <span class="emphasis"><em>initial</em></span> ‘<code class="literal">is</code>’, with the following
letter converted to titlecase.  Thus ‘<code class="literal">number?</code>’ is
converted to ‘<code class="literal">isNumber</code>’ (which fits with Java conventions),
and ‘<code class="literal">file-exists?</code>’ is converted to ‘<code class="literal">isFileExists</code>’
(which doesn't really).
The pair ‘<code class="literal">-&gt;</code>’ is translated to ‘<code class="literal">$To$</code>’.
For example ‘<code class="literal">list-&gt;string</code>’ is translated to ‘<code class="literal">list$To$string</code>’.
</p>
<p>Some symbols are mapped to a mnemonic sequence, starting with a dollar-sign,
followed by a two-character abbreviation.  For example, the less-than
symbol ‘<code class="literal">&lt;</code>’ is mangled as ‘<code class="literal">$Ls</code>’.
See the source code to the <code class="literal">mangleName</code> method in the
<code class="literal">gnu.expr.Compilation</code> class for the full list.
Characters that do not have a mnemonic abbreviation are
mangled as ‘<code class="literal">$</code>’ followed by a four-hex-digit unicode value.
For example ‘<code class="literal">Tamil vowel sign ai</code>’ is mangled as ‘<code class="literal">$0bc8</code>’.
</p>
<p>Note that this mapping may map different Scheme names to the
same Java name.  For example ‘<code class="literal">string?</code>’, ‘<code class="literal">String?</code>’,
‘<code class="literal">is-string</code>’, ‘<code class="literal">is-String</code>’,
and ‘<code class="literal">isString</code>’ are all mapped to the same Java identifier
‘<code class="literal">isString</code>’.  Code that uses such "Java-clashing" names
is <span class="emphasis"><em>not</em></span> supported.  There is very partial support for
renaming names in the case of a clash, and there may be better
support in the future.  However, some of the nice features of
Kawa depend on being able to map Scheme name to Java names
naturally, so we urge you to <span class="emphasis"><em>not</em></span> write code that
"mixes" naming conventions by using (say) the names ‘<code class="literal">open-file</code>’
and ‘<code class="literal">openFile</code>’ to name two different objects.
</p>
<p>The above mangling is used to generate Java method names.
Each top-level definition is also mapped to a Java field.
The name of this field is also mangled, but using a mostly
reversible mapping:  The Scheme function ‘<code class="literal">file-exists?</code>’
is mapped to the method name ‘<code class="literal">file$Mnexists$Qu</code>’.
Because ‘<code class="literal">$</code>’ is used to encode special characters, you
should avoid using it in names in your source file.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="Scheme-types-in-Java"></a>Scheme types in Java</h3></div></div></div>
<p>All Scheme values are implemented by sub-classes of ‘<code class="literal">java.lang.Object</code>’.
</p>
<p>Scheme symbols are implemented using <code class="literal">java.lang.String</code>.
(Don't be confused by the fact the Scheme sybols are represented
using Java Strings, while Scheme strings are represented by
<code class="literal">gnu.lists.FString</code>.  It is just that the semantics of Java strings
match Scheme symbols, but do not match mutable Scheme strings.)
Interned symbols are presented as interned Strings.
(Note that with JDK 1.1 string literals are automatically interned.)
</p>
<p>Scheme integers are implemented by <code class="literal">gnu.math.IntNum</code>.
Use the make static function to create a new IntNum from an int or a long.
Use the intValue or longValue methods to get the int or long value of
an IntNum.
</p>
<p>A Scheme "flonum" is implemented by <code class="literal">gnu.math.DFloNum</code>.
</p>
<p>A Scheme pair is implemented by <code class="literal">gnu.lists.Pair</code>.
</p>
<p>A Scheme vector is implemented by <code class="literal">gnu.lists.FVectror</code>.
</p>
<p>Scheme characters are implemented using <code class="literal">gnu.text.Char</code>.
</p>
<p>Scheme strings are implemented using <code class="literal">gnu.lists.FString</code>.
</p>
<p>Scheme procedures are all sub-classes of <code class="literal">gnu.mapping.Procedure</code>.
The "action" of a ‘<code class="literal">Procedure</code>’ is invoked by using one of
the ‘<code class="literal">apply*</code>’ methods:  ‘<code class="literal">apply0</code>’, ‘<code class="literal">apply1</code>’,
‘<code class="literal">apply2</code>’, ‘<code class="literal">apply3</code>’, ‘<code class="literal">apply4</code>’, or ‘<code class="literal">applyN</code>’.
Various sub-class of ‘<code class="literal">Procedure</code>’ provide defaults
for the various ‘<code class="literal">apply*</code>’ methods.  For example,
a ‘<code class="literal">Procedure2</code>’ is used by 2-argument procedures.
The ‘<code class="literal">Procedure2</code>’ class provides implementations of all
the ‘<code class="literal">apply*</code>’ methods <span class="emphasis"><em>except</em></span> ‘<code class="literal">apply2</code>’,
which must be provided by any class that extends <code class="literal">Procedure2</code>.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="Array-operations"></a>Using Java Arrays</h3></div></div></div>
<p><a name="Creating-new-Java-arrays"></a>
</p>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Creating-new-Java-arrays"></a>Creating new Java arrays</h4></div></div></div>
<p>To allocate a Java array you can use the array type specifier
as a constructor function.  For example, to allocate an array with room for 10 elements
each of each is a primitive <code class="literal">int</code>:
</p>
<pre class="screen">(int[] length: 10)
</pre>
<p>You can specify the initial elements instead of the length:
</p>
<pre class="screen">(object[] 31 32 33 34)
</pre>
<p>This creates a 4-length array, initialized to the given values.
</p>
<p>Note this is a variation of the generation object-allocation
(see <a class="xref" href="Objects-Classes-and-Modules.html#Allocating-objects" title="Kawa: Allocating objects">the section called “Allocating objects”</a>) pattern.  You can explicitly
use the <code class="literal">make</code> function, if you prefer:
</p>
<pre class="screen">(make object[] 31 32 33 34)
</pre>
<p>If you specify a length, you can also specify initial values for selected
elements.
If you specify an index, in the form of a literal integer-valued keyword,
then following elements are placed starting at that position.
</p>
<pre class="screen">(int[] length: 100 10 12 80: 15 16 50: 13 14)
</pre>
<p>This creates an array with 100 elements.  Most of them are initialized
to the default value of zero,
but elements with indexes 0, 1, 50, 51, 80, 81 are initialized
to the values 10, 12, 13, 14, 15, 16, respectively.
</p>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Accessing-Java-array-elements"></a>Accessing Java array elements</h4></div></div></div>
<p>You can access the elements of a Java array by treating it as
a one-argument function, where the argument is the index:
</p>
<pre class="screen">(define primes (integer[] 2 3 5 7 11 13))
(primes 0) ⇒ 2
(primes 5) ⇒ 13
</pre>
<p>You can set an element by treating the array as a function
with a <code class="literal">setter</code>:
</p>
<pre class="screen">(set! (primes 0) -2)
(set! (primes 3) -7)
primes ⇒ [-2 3 5 -7 11 13]
</pre>
<p>To get the number of elements of an array, you can treat
it as having a <code class="literal">length</code> field:
</p>
<pre class="screen">primes:length ⇒ 6
</pre>
<p>Here is a longer example.  This is the actual definition of the
standard <code class="literal">gcd</code> function.  Note the <code class="literal">args</code> variable
receives all the arguments on the form of an <code class="literal">integer</code> array.
(This uses the Java5 varargs feature.)
</p>
<pre class="screen">(define (gcd #!rest (args ::integer[])) ::integer
  (let ((n ::int args:length))
    (if (= n 0)
	0
	(let ((result ::integer (args 0)))
	  (do ((i ::int 1 (+ i 1)))
	      ((&gt;= i n) result)
	    (set! result (gnu.math.IntNum:gcd result (args i))))))))
</pre>
<p>The above example generates good code,
thanks to judicious use of casts and type specifications.
In general, if Kawa knows that
a “function” is an array then it will generate efficient
bytecode instructions for array operations.
</p>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Old-low-level-array-macros"></a>Old low-level array macros</h4></div></div></div>
<p>The deprecated <a class="xref" href="">???</a> are also supported.
</p>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="Loading-Java-functions-into-Scheme"></a>Loading Java functions into Scheme</h3></div></div></div>
<p>When <code class="literal">kawa -C</code> compiles (see <a class="xref" href="Running.html#Files-compilation" title="Kawa: Compiling to a set of .class files">the section called “Compiling to a set of .class files”</a>) a Scheme module
it creates a class that implements the <code class="literal">java.lang.Runnable</code> interface.
(Usually it is a class that extends the <code class="literal">gnu.expr.ModuleBody</code>.)
It is actually fairly easy to write similar "modules" by hand in Java,
which is useful when you want to extend Kawa with  new "primitive functions"
written in Java.  For each function you need to create an object that
extends <code class="literal">gnu.mapping.Procedure</code>, and then bind it in the global
environment.  We will look at these two operations.
</p>
<p>There are multiple ways you can create a <code class="literal">Procedure</code> object.  Below
is a simple example, using the <code class="literal">Procedure1</code> class, which is class
extending <code class="literal">Procedure</code> that can be useful for one-argument
procedure.  You can use other classes to write procedures.  For example
a <code class="literal">ProcedureN</code> takes a variable number of arguments, and you must
define <code class="literal">applyN(Object[] args)</code> method instead of <code class="literal">apply1</code>.
(You may notice that some builtin classes extend <code class="literal">CpsProcedure</code>.
Doing so allows has certain advantages, including support for
full tail-recursion, but it has some costs, and is a bit trickier.)
</p>
<pre class="screen">import gnu.mapping.*;
import gnu.math.*;
public class MyFunc extends Procedure1
{
  // An "argument" that is part of each procedure instance.
  private Object arg0;

  public MyFunc(String name, Object arg0)
  {
    super(name);
    this.arg0 = arg0;
  }

  public Object apply1 (Object arg1)
  {
    // Here you can so whatever you want. In this example,
    // we return a pair of the argument and arg0.
    return gnu.lists.Pair.make(arg0, arg1);
  }
}
</pre>
<p>You can create a <code class="literal">MyFunc</code> instance and call it from Java:
</p>
<pre class="screen">  Procedure myfunc1 = new MyFunc("my-func-1", Boolean.FALSE);
  Object aresult = myfunc1.apply1(some_object);
</pre>
<p>The name <code class="literal">my-func-1</code> is used when <code class="literal">myfunc1</code> is printed
or when <code class="literal">myfunc1.toString()</code> is called.  However,
the Scheme variable <code class="literal">my-func-1</code> is still not bound.
To define the function to Scheme, we can create
a "module", which is a class intended to be loaded
into the top-level environment.  The provides the definitions to be
loaded, as well as any actions to be performed on loading
</p>
<pre class="screen">public class MyModule
{
  // Define a function instance.
  public static final MyFunc myfunc1
    = new MyFunc("my-func-1", IntNum.make(1));
}
</pre>
<p>If you use Scheme you can use <code class="literal">require</code>:
</p>
<pre class="screen">#|kawa:1|# (require &lt;MyModule&gt;)
#|kawa:2|# (my-func-1 0)
(1 0)
</pre>
<p>Note that <code class="literal">require</code> magically defines <code class="literal">my-func-1</code> without
you telling it to.  For each public final
field, the name and value of the field are entered in the
top-level environment when the class is loaded.  (If there are
non-static fields, or the class implements <code class="literal">Runnable</code>, then
an instance of the object is created, if one isn't available.)
If the field value is a <code class="literal">Procedure</code> (or implements <code class="literal">Named</code>),
then the name bound to the procedure is used instead of the field name.
That is why the variable that gets bound in the Scheme environment is
<code class="literal">my-func-1</code>, not <code class="literal">myfunc1</code>.
</p>
<p>Instead of <code class="literal">(require &lt;MyModule&gt;)</code>, you can do <code class="literal">(load "MyModule")</code>
or <code class="literal">(load "MyModule.class")</code>.
If you're not using Scheme, you can use Kawa's <code class="literal">-f</code> option:
</p>
<pre class="screen">$ kawa -f MyModule --xquery --
#|kawa:1|# my-func-1(3+4)
&lt;list&gt;1 7&lt;/list&gt;
</pre>
<p>If you need to do some more complex calculations when a module is loaded,
you can put them in a <code class="literal">run</code> method, and have the module
implement <code class="literal">Runnable</code>:
</p>
<pre class="screen">public class MyModule implements Runnable
{
  public void run ()
  {
    Interpreter interp = Interpreter.getInterpreter();
    Object arg = Boolean.TRUE;
    interp.defineFunction (new MyFunc ("my-func-t", arg));
    System.err.println("MyModule loaded");
  }
}
</pre>
<p>Loading <code class="literal">MyModule</code> causes <code class="literal">"MyModule loaded"</code> to be printed,
and <code class="literal">my-func-t</code> to be defined.  Using <code class="literal">Interpreter</code>'s
<code class="literal">defineFunction</code> method is recommended because it does the righ
things even for languages like Common Lisp that use separate
"namespaces" for variables and functions.
</p>
<p>A final trick is that you can have a <code class="literal">Procedure</code> be its own module:
</p>
<pre class="screen">import gnu.mapping.*;
import gnu.math.*;
public class MyFunc2 extends Procedure2
{
  public MyFunc(String name)
  {
    super(name);
  }

  public Object apply2 (Object arg1, arg2)
  {
    return gnu.lists.Pair.make(arg1, arg2);
  }

  public static final MyFunc myfunc1 = new MyFunc("my-func-2);
}
</pre>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="Evaluating-Scheme-expressions-from-Java"></a>Evaluating Scheme expressions from Java</h3></div></div></div>
<p>The following methods are recommended if you need to evaluate a
Scheme expression from a Java method.
(Some details (such as the ‘<code class="literal">throws</code>’ lists) may change.)
</p>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp49413552"></a><span class="returnvalue">void</span><code class="function">Scheme.registerEnvironment</code> ()</p>
<div class="blockquote"><blockquote class="blockquote"><p>Initializes the Scheme environment.  Maybe needed if you
try to load a module compiled from a Scheme source file.
</p></blockquote></div>
</div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp49417376"></a><span class="returnvalue">Object</span><code class="function">Scheme.eval</code> (<span class="type">InPort</span> <em class="replaceable"><code>port</code></em>,<span class="type"> Environment</span> <em class="replaceable"><code>env</code></em>)</p>
<div class="blockquote"><blockquote class="blockquote"><p>Read expressions from <em class="replaceable"><code>port</code></em>, and evaluate them in the
<em class="replaceable"><code>env</code></em> environment, until end-of-file is reached.
Return the value of the last expression,
or <code class="literal">Interpreter.voidObject</code> if there is no expression.
</p></blockquote></div>
</div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp49424352"></a><span class="returnvalue">Object</span><code class="function">Scheme.eval</code> (<span class="type">String</span> <em class="replaceable"><code>string</code></em>,<span class="type"> Environment</span> <em class="replaceable"><code>env</code></em>)</p>
<div class="blockquote"><blockquote class="blockquote"><p>Read expressions from <em class="replaceable"><code>string</code></em>, and evaluate them in the
<em class="replaceable"><code>env</code></em> environment, until the end of the string is reached.
Return the value of the last expression,
or <code class="literal">Interpreter.voidObject</code> if there is no expression.
</p></blockquote></div>
</div>
<div class="informalfigure">
<p class="synopsis"><a class="indexterm" name="idp49431328"></a><span class="returnvalue">Object</span><code class="function">Scheme.eval</code> (<span class="type">Object</span> <em class="replaceable"><code>sexpr</code></em>,<span class="type"> Environment</span> <em class="replaceable"><code>env</code></em>)</p>
<div class="blockquote"><blockquote class="blockquote"><p>The <em class="replaceable"><code>sexpr</code></em> is an S-expression (as may be returned by <code class="literal">read</code>).
Evaluate it in the <em class="replaceable"><code>env</code></em> environment, and return the result.
</p></blockquote></div>
</div>
<p>For the <code class="literal">Environment</code> in most cases you could use
‘<code class="literal">Environment.current()</code>’.  Before you start, you
need to initialize the global environment,
which you can with
</p>
<pre class="screen">Environment.setCurrent(new Scheme().getEnvironment());
</pre>
<p>Alternatively, rather than setting the global environment,
you can use this style:
</p>
<pre class="screen">Scheme scm = new Scheme();
Object x = scm.eval("(+ 3 2)");
System.out.println(x);
</pre>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="Using-javax.script-portable-Java-scripting"></a>Using <code class="literal">javax.script</code> portable Java scripting</h4></div></div></div>
<p>Kawa also supports the standard
<a class="ulink" href="http://docs.oracle.com/javase/7/docs/api/javax/script/package-summary.html" target="_top"><code class="literal">javax.script</code></a> API.
The main advantage of this API is if you want your users to be able to chose
between multiple scripting languages.  That way you can support Kawa
without Kawa-specific programming.
</p>
<p>For example the standard JDK tool <a class="ulink" href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jrunscript.html" target="_top">jrunscript</a> provides a
read-eval-print-loop for any language that implements the  <code class="literal">javax.script</code>
API.  It knows nothing about Kawa but can still use it:
</p>
<pre class="screen">$ jrunscript -cp kawa.jar -l scheme
scheme&gt; (cadr '(3 4 5))
4
</pre>
<p>(Of course the <code class="literal">jrunscript</code> REPL isn't as  nice as the one that
Kawa provides.  For example the latter can handle multi-line inputs.)
</p>
</div>
</div>
</div>
<div class="navfooter">
<ul>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Defining-new-classes">Defining new classes</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Anonymous-classes">Anonymous classes</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Enumerations">Enumeration types</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Annotations">Annotations of declarations</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Module-classes">Modules and how they are compiled to classes</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Record-types">Record types</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Dynamic-records">Creating New Record Types On-the-fly</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Method-operations">Calling Java methods from Scheme</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Allocating-objects">Allocating objects</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Field-operations">Accessing object fields</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Mangling">Mapping Scheme names to Java names</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Scheme-types-in-Java">Scheme types in Java</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Array-operations">Using Java Arrays</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Loading-Java-functions-into-Scheme">Loading Java functions into Scheme</a></b></li>
<li><b class="toc"><a href="Objects-Classes-and-Modules.html#Evaluating-Scheme-expressions-from-Java">Evaluating Scheme expressions from Java</a></b></li>
</ul>
<p>
          Up: <a accesskey="u" href="Documentation.html">Documentation</a></p>
<p>
        Previous: <a accesskey="p" href="Types.html">Types</a></p>
<p>
        Next: <a accesskey="n" href="XML-tools.html">Working with XML and HTML</a></p>
</div>
</body>
</html>
